<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的四种引用]]></title>
    <url>%2F2021%2F06%2F20%2FJava%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[众所周知，在Java中不需要程序员去主动管理内存，由JVM去负责内存的回收和分配。这样一来简化了程序员的工作，但是呢这也带来一个问题，就是不够灵活，垃圾回收对于程序员来说是不可控的。 在JDK1.2以前，如果一个对象不被任何变量引用，则程序无法再次使用这个对象，这个对象最终会被GC（GabageCollection：垃圾回收）。但是如果之后可能还会用到这个对象，就只能去新建一个了，这其实就降低了JVM性能，没有达到最大的优化策略。 因此，从JDK1.2开始，提供了四种类型的引用：强引用（StrongReference）、软引用（SoftReference）、弱引用（WeakReference）和虚引用（PhantomReference）。主要有两个目的： 可以在代码中决定某些对象的生命周期； 优化JVM的垃圾回收机制。 四种引用类型强引用强引用是最普遍的引用，如果一个对象具有强引用，那么即使内存不足（JVM抛出OutOfMemoryError），该对象也不会被回收。 12// obj就是一个强引用Object obj = new Object(); 软引用如果一个对象只具有软引用，当内存空间足够的时候，它就不会被回收，只有当内存不足的时候， 软引用才会被回收。JVM会优先回收长时间闲置不用的软引用的对象，对那些刚刚构建的或刚刚使用过的“新”软引用对象会尽可能保留。软引用可以和引用队列配合使用，如果一个对象即将被垃圾回收了，那么该软引用将会被添加到引用队列里。 1234567891011 Object obj = new Object(); SoftReference&lt;Object&gt; reference = new SoftReference&lt;&gt;(obj); reference.get();// 和引用队列配合使用 Object obj = new Object(); ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;(); SoftReference&lt;Object&gt; reference = new SoftReference&lt;&gt;(obj, queue); // 返回队列中的软引用并移除 queue.poll(); 弱引用持有弱引用的对象只能存活到下一次垃圾回收发生之前，无论内存空间是否足够，弱引用都会被回收。不过由于垃圾收集线程是一个优先级很低的线程，可能弱引用无法被及时回收。 12345678910111213141516171819202122Object obj = new Object();ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();WeakReference&lt;Object&gt; reference = new WeakReference&lt;&gt;(obj, queue);System.out.println("obj:" + obj);System.out.println("queue:" + queue.poll());System.out.println("reference:" + reference);System.out.println("reference.get():" + reference.get()); //不为null，其余和虚引用一样obj = null;//不要使用下一行代码，因为下一行代码会导致reference对象被GC回收，导致queue的poll()返回空// reference = null; //这句话会导致下面的queue.poll()返回空，即reference对象都被回收了！！！System.gc();Thread.sleep(2000);System.out.println("-----after gc-----------");System.out.println("obj:" + obj);// System.out.println("queue:" + queue.poll());// poll方法返回 队列中的弱引用，并移除弱引用if (queue.poll() != null) &#123; // obj对象即将被回收，执行业务逻辑，比如清理queue和reference对象 System.out.println("adfdcxd");&#125;System.out.println("reference:" + reference);System.out.println("reference.get():" + reference.get()); 虚引用与其它三种引用不同的是，虚引用不会决定对象的生命周期，如果一个对象持有虚引用，那么它就等于和没有任何引用一样，无法通过虚引用获取到该对象，在任何时候都可能被垃圾回收。虚引用主要作用是跟踪对象被垃圾回收的活动。虚引用必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 123456789101112131415161718192021Object obj = new Object();ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; reference = new PhantomReference&lt;&gt;(obj, queue);System.out.println("obj:" + obj);System.out.println("queue:" + queue.poll());System.out.println("reference:" + reference);System.out.println("reference.get():" + reference.get()); //为null，其余和虚引用一样// 去除obj的强引用obj = null;//不要使用下一行代码，因为下一行代码会导致reference对象被GC回收，导致queue的poll()返回空// reference = null; //这句话会导致下面的queue.poll()返回空，即reference对象都被回收了！！！System.gc();Thread.sleep(2000);System.out.println("-----after gc-----------");System.out.println("obj:" + obj);// System.out.println("queue:" + queue.poll());if (queue.poll() != null) &#123; // obj对象即将被回收，执行业务逻辑&#125;System.out.println("reference:" + reference);System.out.println("reference.get():" + reference.get()); 我们可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取相应的措施。 参考 Java中的四种引用类型 深入理解Java虚拟机]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel大数据导入导出]]></title>
    <url>%2F2021%2F04%2F05%2FExcel%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[Excel大数据导入导出在Java中我们导入导出Excel一般使用的是Apache POI，很多开源工具也都是基于POI的。但是POI的使用不当可能会造成线上问题，比如数据量大的时候会造成Full GC或者OOM。 从上图中可以看到POI相关的对象以及相关的XML对象占用了大量的内存空间，而且造成了频繁的 Full GC，但是却一直没有被回收。原因是导出的数据比较大，在导出结束前内存中有大量的Row，Cell，Style等没有被释放。 Excel存储格式XLS03版的XLS采用的是一种名为BIFF8(Binary-Interchange-File-Format)，基于OLE2规范的二进制文件格式。大家也没必要去了解它，已经被淘汰了。 XLSX07版的XLSX则是采用OOXML(Office Open Xml)的格式存储数据。简单来说就是一堆xml文件用zip打包之后文件。这个对于大家来说就熟悉了，把xlsx文件后缀名改为zip后，再解压出来就可以看到文件结构。 导出优化由于xlsx底层使用xml存储，占用内存会比较大，官方也意识到这个问题，在3.8版本之后，提供了SXSSFWorkbook来优化写性能。 使用1Workbook workbook = new XSSFWorkbook(inputStream); 改成如下代码即可。 1Workbook workbook = new SXSSFWorkbook(new XSSFWorkbook(inputStream)); 原理其原理是可以定义一个window size（默认100），生成Excel期间只在内存维持window size那么多的行数Row，超时window size时会把之前行Row写到一个临时文件并且remove释放掉，这样就可以达到释放内存的效果。 SXSSFSheet在创建Row时会判断并刷盘、释放超过window size的Row。 我们可以看到 SXSSFSheet在创建的时候，都会创建一个SheetDataWriter，刷盘动作正是由这个类完成的，调用 writeRow 方法。 导入优化用户模式（UserModel）用户模式（User Model）就类似于dom方式的解析，是一种high level api，给人快速、方便开发用的。缺点是一次性将文件读入内存，构建一颗Dom树。并且在POI对Excel的抽象中，每一行，每一个单元格都是一个对象。当文件大，数据量多的时候对内存的占用可想而知。 用户模式就是类似用 WorkbookFactory.create(inputStream)，poi 会把整个文件一次性解析，生成全部的Sheet，Row，Cell以及对象，如果导入文件数据量大的话，也很可能会导致OOM。 事件模式（EventModel）事件模式（Event Model）就是SAX解析。Event Model使用的方式是边读取边解析，并且不会将这些数据封装成Row，Cell这样的对象。而都只是普通的数字或者是字符串。并且这些解析出来的对象是不需要一直驻留在内存中，而是解析完使用后就可以回收。所以相比于User Model，Event Model更节省内存，效率也更。但是作为代价，相比User Model功能更少，门槛也要高一些。我们需要去学习Excel存储数据的各个Xml中每个标签，标签中的属性的含义，然后对解析代码进行设计。 用户事件模式（User Event Model）User Event Model也是采用流式解析，但是不同于Event Model，POI基于Event Model为我们封装了一层。我们不再面对Element的事件编程,而是面向StartRow，EndRow，Cell等事件编程。而提供的数据，也不再像之前是原始数据，而是全部格式化好，方便开发者开箱即用。大大简化了我们的开发效率。 XLSXPOI对XLSX支持Event Model和Event User Model。 官方例子简单来说就是继承XSSFSheetXMLHandler.SheetContentsHandler，覆盖其startRow，endRow，cell，endSheet 等方法。POI每开始读行，结束读行，读取一个cell，结束读取一个sheet时回调的方法。从方法名上看Event User Model有更好的用户体验。 XLSPOI对XLS支持Event Model。 需要继承HSSFListener，覆盖processRecord 方法，POI每读取到一个单元格的数据则会回调次方法。 参考 Excel 大批量数据的导入和导出，如何做优化？]]></content>
      <categories>
        <category>excel</category>
      </categories>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAT内存分析工具的使用]]></title>
    <url>%2F2020%2F12%2F02%2FMAT%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Eclipse Memory Analyzer是一个快速且功能丰富的Java堆分析器，可帮助您查找内存泄漏并减少内存消耗。使用Memory Analyzer分析具有数亿个对象的高效堆转储，快速计算对象的保留大小，查看谁阻止垃圾收集器收集对象，运行报告以自动提取泄漏嫌疑者。下面来介绍下MAT工具如何使用。 获取Heap Dump文件 通过OOM获取，即在OutOfMemoryError后获取一份HPROF二进制Heap Dump文件，可以在jvm里添加参数： -XX:+HeapDumpOnOutOfMemoryError 主动获取，即在虚拟机添加参数如下，然后在Ctrl+Break组合键即可获取一份Heap Dump -XX:+HeapDumpOnCtrlBreak 使用HPROF agent 使用Agent可以在程序执行结束时或受到SIGOUT信号时生成Dump文件。配置在虚拟机的参数如下： -agentlib:hprof=heap=dump,format=b jmap 可以在cmd里执行，命令如下： jmap -dump:format=b,file=&lt;文件名XX.hprof&gt; &lt;pid&gt; 使用JConsole 使用Memory Analyzer Tools的File —&gt; Acquire Heap Dump功能 导入Head Dump文件一般选择 Leak Suspects Report。 MAT常用操作Histogram是我们使用最多的一个，可以列出内存中的对象，对象的个数及其大小 Class Name ： 类名称，java类名 Objects ： 类的对象的数量，这个对象被创建了多少个 Shallow Heap ：一个对象内存的消耗大小，不包含对其他对象的引用 Retained Heap ：是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和 右键某个类可以查看某个类被哪些类引用了，以及引用了哪些类。 with outgoing references，查看该类内部引用了哪些类 with incoming references，查看该类被哪些类引用了 快速找到某个实例没被释放的原因。 Dominator Tree 列出线程的树结构，及线程下面对象占用内存的空间 Top Comsumers 通过图型列出最大的Object 参考 10 Tips for using the Eclipse Memory Analyzer - EclipseSource JVM 内存分析神器 MAT: Incoming Vs Outgoing References 你真的了解吗？ - 云+社区 - 腾讯云 (tencent.com) MemoryAnalyzer - Eclipsepedia 项目demo monitor-tunning MAT入门到精通（一） (qq.com)]]></content>
      <categories>
        <category>MAT</category>
      </categories>
      <tags>
        <tag>MAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shallow Size 和 Retained Size]]></title>
    <url>%2F2020%2F11%2F23%2FShallow%20Size%20%E5%92%8C%20Retained%20Size%2F</url>
    <content type="text"><![CDATA[在使用MAT工具分析JVM内存占用情况的时候，我们经常会遇到两个出现频率很高的名词 Shallow Size 和 Retained Size。 这两个名词代表的是对象所占用的内存大小（JAVA对象大小=对象头+实例数据+对齐填充）。 下面是Mat文档里对Shallow Size 和 Retained Size的解释： Shallow heap is the amount of memory consumed by one object. An Object requires 32 (or 64 bits, depending on the architecture) for each reference. Primitives such as integers and longs require 4 or 8 bytes, etc… While this can be interesting, the more useful metric is the Retained Heap. The retained heap shows the sum of the shallow heap size of all objects that would be removed when this object is garbage collected. For example, if an ArrayList held 100,000 items, and each item required 16 bytes, then removing the ArrayList would free 16 x 100,000 + X, where X is the shallow size of the ArrayList. (Note: this assumes that these objects are only being referenced by the ArrayList, and not elsewhere). The retained heap is computed by adding the size all the objects in the retained set. A retained set of X is the set of objects which would be removed by the GC when X is collected. The retained heap can be calculated in two different ways, using the quick approximation or the precise retained size. Shallow Size非数组类型的对象的Shallow Sizeshallow_size=对象头+各成员变量大小之和+对齐填充 这里的各成员变量大小之和就是实例数据，如果存在继承情况，当然要包含父类的成员变量。 注：记住不包含所引用的对象本身的大小。 数组类型对象的Shallow Sizeshallow_size=对象头+类型变量大小*数组长度+对齐填充，其中如果类型是引用类型则是4字节或8字节（64位系统）,如果是boolean类型则是1字节，以此类推。 注：这里的类型变量大小*数组长度就是实例数据，强调是变量不是对象本身。 Retained SizeRetained Size 对象本身大小（即shallow heap大小）与其所引用对象大小之和。 换个说法就是当前对象被GC后，从Heap上总共能释放掉的内存，强调是GC后能释放的。即要排除被GC Roots直接或间接引用的对象。 当然这里面还会包括一些java语言特性的数据存储单元，就是说实际retained size会比我们计算出来的大一点。 图中 GC Roots直接引用了A和B两个对象，对象A的Retained Size = 对象A的Shallow Size B对象的Retained Size = B对象的Shallow Size + C对象的Shallow Size，需要注意的是，这里是不包括 D对象的，因为D对象还被GC Roots 引用了。如果D对象没有被GC Roots 引用，那么 B对象的Retained Size = B 对象的Shallow Size + C对象的Shallow Size + D对象的Shallow Size。 非数组对象的Retained SizeRetained Size=当前对象shallow_size+当前对象可直接或间接引用到的对象的shallow_size总和。(间接引用的含义：A-&gt;B-&gt;C, C就是间接引用)。 数组对象的Retained Size数组的元素类型是引用类型Retained Size=数组对象的shallow_size+数组中各个引用对象的shallow_size之和。 数组的元素类型为基本数据类型Retained Size=数组对象的shallow_size+数组中各基本数据类型大小之和。 参考资料 Shallow heap &amp; Retained heap 10 Tips for using the Eclipse Memory Analyzer - EclipseSource]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis线程模型解析]]></title>
    <url>%2F2020%2F11%2F21%2FRedis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Redis的线程模型 Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。 Redis既然是单线程的，那么它是如何监听大量的客户端请求的呢？ Redis通过 IO多路复用程序来监听来自客户端的大量连接（socket套接字），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。 这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。 另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。 时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。 Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。 以上的说法并不意味着redis只能以单线程的方式运行，在redis4.0之后的版本就已经加入了对多线程的支持（仅限于对大键值的删除操作，Redis6.0引入了多线程主要是为了提高IO读写能力，执行命令这种还是单线程顺序执行，默认Redis6.0是禁用多线程的。）。 持久化原理Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。 快照（snapshotting）持久化（RDB）Redis可以通过创建快照来获得存储在内存里的数据某个时间节点的副本。可以对这个快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 RDB是redis默认的持久化方式，在redis.conf中有以下默认配置。 123save 900 1 #在900s之后，如果至少有一个key发生了变化，那么redis就会触发bgsave命令创建快照save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 AOF（append-only file）持久化与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： 1appendonly yes 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是： 123appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘appendfsync no #让操作系统决定何时进行同步 为了兼顾数据备份准确性和性能，一般采用 每秒钟同步一次（appendfsync everysec）的备份策略， 持久化机制的优化混合持久化Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。 如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。 aof重写AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。 AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。 在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。 无磁盘化复制 Redis的主从复制，过程是master先将内存中的数据以RDB文件的形式保存在本地磁盘，然后将RDB文件传输给slave的磁盘，slave再将接受到的RDB文件加载到内存中。这是默认的主从复制过程，需要经过磁盘。但如果是普通机械硬盘，硬盘读写效率低下。这样就出现了无磁盘化复制，从而提高了效率。默认是关闭的。使用的时候把no改为yes。 12345repl-diskless-sync no# 这一点很重要，因为一旦传输开始，就不可能服务新的从服务器到达，它将排队等待下一次RDB传输，所以服# 务器等待延迟以便让更多的从节点到达。延迟以秒为单位指定，默认为5秒。禁用它完全只是设置为0秒，传# 输将尽快开始。repl-diskless-sync-delay 5 内存淘汰策略和缓存过期机制缓存过期机制（主动）定期删除（1s中检查10次，可以配置）设置的 hz参数过高，CPU占用率会越高，一般采用默认设置 10 即可。 （被动）惰性删除客户端会获取到过期的key，这个时候会检测这个key有没有过期，过期了直接从内存中删除，这种策略不会 占用太多的CPU资源，缺点是如果一个过期的key没有被访问到，那么这个key会一直存在于内存中。 内存淘汰策略如果某个时候Redis中所使用的内存，已经达到了设置的阈值，那么一些key会被清理掉。 Redis4.0之前提供以下六种数据淘汰策略。 volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ Redis4.0之后增加了以下两种。 volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key Redis高可用策略和集群Redis 高可用策略（主从&amp;哨兵）基本概念高可用（High Availability），是当一台服务器停止服务后，对于业务及用户毫无影响。 停止服务的原因可能由于网卡、路由器、机房、CPU负载过高、内存溢出、自然灾害等不可预期的原因导致，在很多时候也称单点问题。 主备方式（简单情景） 这种通常是一台主机、一台或多台备机，在正常情况下主机对外提供服务，并把数据同步到备机，当主机宕机后，备机立刻开始服务。 Redis HA中使用比较多的是keepalived，它使主机备机对外提供同一个虚拟IP，客户端通过虚拟IP进行数据操作，正常期间主机一直对外提供服务，宕机后VIP自动漂移到备机上。优点是对客户端毫无影响，仍然通过VIP操作。 缺点也很明显，在绝大多数时间内备机是一直没使用，被浪费着的。 主从方式（推荐） 这种采取一主多从的办法，主从之间进行数据同步。 当Master宕机后，通过选举算法(Paxos、Raft)从slave中选举出新Master继续对外提供服务，主机恢复后以slave的身份重新加入。 主从另一个目的是进行读写分离，这是当单机读写压力过高的一种通用型解决方案。 其主机的角色只提供写操作或少量的读，把多余读请求通过负载均衡算法分流到单个或多个slave服务器上。 缺点是主机宕机后，Slave虽然被选举成新Master了，但对外提供的IP服务地址却发生变化了，意味着会影响到客户端。 解决这种情况需要一些额外的工作，在当主机地址发生变化后及时通知到客户端，客户端收到新地址后，使用新地址继续发送新请求。 方案选择 主备（keepalived）方案配置简单、人力成本小，在数据量少、压力小的情况下推荐使用。 如果数据量比较大，不希望过多浪费机器，还希望在宕机后，做一些自定义的措施，比如报警、记日志、数据迁移等操作，推荐使用主从方式，因为和主从搭配的一般还有个管理监控中心。 主从拓扑Redis的主从拓扑支持单层或者多层结构，可分为一主一从，一主多从，树状主从。 一主一从：用于主节点故障转移从节点，当主节点的“写”命令并发高且需要持久化，可以只在从节点开启AOF（主节点不需要），这样即保证了数据的安全性，也避免持久化对主节点的影响。 一主多从：针对“读”较多的场景，“读”由多个从节点来分担，但节点越多，主节点同步到多节点的次数也越多，影响带宽，也加重主节点的负担。 树状主从：一主多从的缺点（主节点推送次数多压力大）可用些方案解决，主节点只推送一次数据到从节点1，再由从节点2推送到11，减轻主节点推送的压力。 哨兵机制前面介绍了主从机制，但是从运维角度来看，主节点出现了问题我们还需要通过人工干预的方式把从节点设为主节点，还要通知应用程序更新主节点地址，这种方式非常繁琐笨重， 而且主节点的读写能力都十分有限，有没有较好的办法解决这两个问题，哨兵机制就是针对第一个问题的有效解决方案，第二个问题则有赖于集群！哨兵的作用就是监控Redis系统的运行状况，其功能主要是包括以下三个： 监控(Monitoring): 哨兵(sentinel) 会不断地检查你的Master和Slave是否运作正常。 提醒(Notification): 当被监控的某个 Redis出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移(Automatic failover): 当主数据库出现故障时自动将从数据库转换为主数据库。 哨兵的原理：Redis哨兵的三个定时任务，Redis哨兵判定一个Redis节点故障不可达主要就是通过三个定时监控任务来完成的： 每隔10秒每个哨兵节点会向主节点和从节点发送&quot;info replication&quot; 命令来获取最新的拓扑结构 每隔2秒每个哨兵节点会向Redis节点的_sentinel_:hello频道发送自己对主节点是否故障的判断以及自身的节点信息，并且其他的哨兵节点也会订阅这个频道来了解其他哨兵节点的信息以及对主节点的判断 每隔1秒每个哨兵会向主节点、从节点、其他的哨兵节点发送一个 “ping” 命令来做心跳检测。 如果在定时Job3检测不到节点的心跳，会判断为“主观下线”。如果该节点还是主节点那么还会通知到其他的哨兵对该主节点进行心跳检测，这时主观下线的票数超过了&lt;quorum&gt;数时，那么这个主节点确实就可能是故障不可达了，这时就由原来的主观下线变为了“客观下线”。 故障转移和Leader选举 如果主节点被判定为客观下线之后，就要选取一个哨兵节点来完成后面的故障转移工作，选举出一个leader，这里面采用的选举算法为Raft。选举出来的哨兵leader就要来完成故障转移工作，也就是在从节点中选出一个节点来当新的主节点，这部分的具体流程可参考引用. Redis 分布式集群 集群至少部署两台Redis服务器构成一个小的集群，主要有2个目的： 高可用性：在主机挂掉后，自动故障转移，使前端服务对用户无影响。 读写分离：将主机读压力分流到从机上。 在Redis集群设计包括2部分：哈希Slot和节点主从。 节点主从这部分实际在前面的主从拓扑中已经提及，1个Master配备有N个slaver，而且Slaver也可以有自己的Slaver，由于这种主从的关系决定他们是在配置阶段就要指定他们的上下级关系，而不是Zookeeper那种平行关系。节点主从上可以实现读写分离，Master只负责写和同步数据给Slaver，Slaver承担了被读的任务，所以Slaver的扩容只能提高读效率不能提高写效率。 优点：读写分离，通过增加Slaver可以提高并发读的能力。 缺点：Master写能力是瓶颈。维护Slaver开销总将会变成瓶颈，同时Master的Disk大小也将会成为整个Redis集群存储容量的瓶颈。 哈希Slot说白了就像是数据库的分库分表，把整个数据按分区规则映射到多个节点，即把数据划分到多个节点上，每个节点负责整体数据的一个子集。每个Node节点被平均分配了一个Slot段，对应着0-16384，Slot不能重复也不能缺失，否则会导致对象重复存储或无法存储。Node之间也互相监听，一旦有Node退出或者加入，会按照Slot为单位做数据的迁移。 优点：将Redis的写操作分摊到了多个节点上，提高写的并发能力，扩容简单。 缺点：每个Node承担着互相监听、高并发数据写入、高并发数据读出，工作任务繁重 大集群时代集群3.0时代：主从和哈希的设计优缺点正好是相互弥补的，可先Hash分逻辑节点，然后每个逻辑节点内部是主从结构，想扩展并发读就添加Slaver，想扩展并发写就添加Master，想扩容也就是添加Master，任何一个Slaver或者几个Master挂了都不会是灾难性的故障。 总结以下其优缺点： 优点：无中心节点；数据按照 slot 存储分布在多个 Redis 实例上；平滑的进行扩容/缩容节点；自动故障转移(节点之间通过 Gossip 协议交换状态信息，进行投票机制完成 Slave 到 Master 角色的提升)；降低运维成本，提高了系统的可扩展性和高可用性。 缺点：严重依赖外部 Redis-Trib；缺乏监控管理；需要依赖 Smart Client(连接维护, 缓存路由表, MultiOp 和 Pipeline 支持)；Failover 节点的检测过慢，不如“中心节点 ZooKeeper”及时；Gossip 消息的开销；无法根据统计区分冷热数据；Slave“冷备”，不能缓解读压力。 Redis集群+Proxy：当数据量持续增加时，应用可根据不同场景下的业务申请对应的分布式集群。 这块最关键的是缓存治理这块，其中最重要的部分是加入了代理服务。 应用通过代理访问真实的Redis服务器进行读写，这样做的好处是： 避免越来越多的客户端直接访问Redis服务器难以管理，而造成风险。 在代理这一层可以做对应的安全措施，比如限流、授权、分片。 避免客户端越来越多的逻辑代码，不但臃肿升级还比较麻烦。 代理这层无状态的，可任意扩展节点，对于客户端来说，访问代理跟访问单机Redis一样。 目前有公司使用的是客户端组件和代理两种方案并存，因为通过代理会影响一定的性能。 代理这块对应的方案实现有Twitter的Twemproxy和豌豆荚的codis。 参考 Redis高可用策略与集群方案 三张图秒懂Redis集群设计原理_咖啡男孩之SRE之路-CSDN博客_redis集群原理 这可能是目前最全的Redis高可用技术解决方案_时光钟摆-CSDN博客_redis高可用方案 深入理解Redis哨兵搭建及原理_Nuomizhende45-CSDN博客_redis哨兵工作原理 Redis集群架构及对比_u013473512的博客-CSDN博客_redis集群架构 Redis面试题及分布式集群_yajlv的专栏-CSDN博客_redis面试题 Redis Sentinel Documentation – Redis]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的常量池]]></title>
    <url>%2F2020%2F06%2F08%2FJava%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[Class文件常量池Class文件中除了有类的版本、方法、字段等描述信息以外，还有一项信息是常量池，用于存放编译期生成的字面量和符号引用。这部分内容将在类加载以后存放在运行时常量池中。 字面量字面量包括字符串和被final修饰的变量。下面几张图是Class常量池里的字面量（通过jclasslib查看，也可以通过javap -v XXX.class查看字节码信息） 符号引用符号引用包括以下： 类和接口的全限定名称，比如StringBuilder类的全限定名就是：java/lang/StringBuilder 字段的名称和描述符：名称即代码中定义的变量名（包括成员变量、实例变量（实例变量如果是基本数据类型，那么只保存名称和描述符，不保存字面量）和局部变量（描述同实例变量）），描述符（比如： int 变量描述符为I，int[] 为[I） 方法的名称和描述符：名称即代码中定义的方法名，描述符:按照先参数列表后返回值的顺序描述（比如：String::toString()的描述符为 ()Ljava/lang/String)； 运行时常量池运行时常量池是方法区（JDK1.7之前用永久代来实现方法区，JDK1.8之后改为元空间）的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池(Constant Pool Table)，存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池。 我们上面所说的class文件常量池在类加载后会进入方法区中的运行时常量池中，并且需要注意的是运行时常量池是全局共享的，多个类共享一个运行时常量池。 值得一提的是，运行时常量池相对于class文件常量池的另一个特征就是具有动态性，Java语言并不要求常量只在编译时期产生。运行期也可能有新的常量放入常量池中(否则为什么叫运行时常量池呢，如果所有的常量都在编译时产生那么运行时常量池和class文件常量池又有什么区别)。典型的应用就是String::intern()。 在JDK1.6的时候，调用这个方法虚拟机会在字符串常量池在查找是否有与当前字符串相等(equals)的对象，如果有，则返回这个对象；如果没有，则会在字符串常量池中添加这个对象。注意，是把这个对象添加到字符串常量池。 在jdk1.7以后，调用这个方法虚拟机会在字符串常量池在查找是否有与当前字符串相等(equals)的对象，如果有，则返回这个对象的引用；如果没有，则会在字符串常量池中添加这个对象的引用。注意，这个时候添加的是对象在堆中的引用。 字符串常量池(String constant pool)字符串常量池是用来存放字符串的也就是说class文件常量池中的文本字符串会在类加载时进入字符串常量池。那么字符串常量池和运行时常量池是什么关系呢？即运行时常量池逻辑上是包含字符串常量池的。然而，在jdk1.7以后，字符串常量池就被移出了方法区，放到了堆内存中,此时运行时常量池剩下的部分还在永久代，运行时常量池逻辑上是包含字符串常量池的。jdk1.8以后，永久代也被移除了，jvm使用元空间(Meta space)代替永久代成为方法区的具体实现。 HotSpot VM里，记录interned string的一个全局表叫做StringTable，它本质上就是个HashSet，内部数据结构是哈希表，默认值大小长度为1009，这是个纯运行时的结构，而且是惰性（lazy）维护的。注意它只存储对java.lang.String实例的引用，而不存储String对象的内容。 注意，它只存了引用，根据这个引用可以得到具体的String对象。 一般我们说一个字符串进入了全局的字符串常量池其实是说在这个StringTable中保存了对它的引用，反之，如果说没有在其中就是说StringTable中没有对它的引用。 在JDK6.0 中，StringTable 的长度是固定的，长度就是1009，因此如果放入 String Pool 中的 String 非常多，就会造成 hash 冲突，导致链表过长，当调用 String#intern() 时会需要到链表上一个一个找，从而导致性能大幅度下降； 在 JDK7.0以上版本中，StringTable 的长度可以通过参数指定： 1-XX:StringTableSize=66666 参考 聊一聊Java中的各种常量池 Java 中new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? 深入解析String#intern JDK1.8关于运行时常量池, 字符串常量池的要点 JVM源码分析之String.intern()导致的YGC不断变长 https://zhuanlan.zhihu.com/p/107776367]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类加载机制]]></title>
    <url>%2F2020%2F06%2F06%2F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。需要注意的是，在Java语言里面，类型的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会导致类加载时稍微增加一些性能开销，但是给Java应用程序提供了高度的灵活性，比如说编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。 类加载的时机类从被加载到虚拟机内存中开始，到卸载处内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载这个七个阶段，其中验证、准备、解析属于连接阶段。 其中，加载、验证、准备、解析、初始化和卸载这5个阶段顺序是确定的，类的加载过程必须按照这种顺序按部就班的进行，但是解析阶段却不一定。在某些情况下，解析可以在初始化之后再开始，这是为了支持Java语言的运行时绑定。这里需要注意的是，这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段的执行的过程中调用、激活另外一个阶段。 上面说了那么多，什么时候会开始类加载的第一个阶段：加载呢？Java虚拟机规范中并没有强制约束这一点，这一点虚拟机可以自由实现。但是对于初始化阶段，虚拟机规范则是严格规定了有且仅有5中情况必须立即对类进行初始化（加载、验证、准备自然需要在此之前开始）。 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先初始化。比如说使用new关键字实例化对象的时候，读取或设置一个类的静态变量（被final修饰、已在编译期把结果放入常量池的静态字段除外），以及调用类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，那么先要对类进行初始化。 当初始化一个类的时候，如果发现其父类没有进行初始化，那么要先初始化父类。 1接口的初始化这里和类的初始化有点区别：接口在初始化的时候，并不要求父接口全部完成了初始化，只有在真正使用到父接口的时候（比如引用接口中定义的常量）才会初始化。 当虚拟机启动时，用户需要指定一个主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持的时候，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄、并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 类加载的过程加载加载 是 类加载 过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的的类的静态数据结构转换为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象（默认存放在堆中（JDK1.8之前（不包括1.8）可以通过参数修改设置JavaObjectsInPerm，UnlockDiagnosticVMOptions来设置存放在方法区），Klass数据才是存放在元空间或者方法区，参考JVM源码分析之Metaspace解密），作为这个类的各种数据访问入口。 还有一点需要注意的是，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但数组类与类加载器仍然有很大的关系，因为数组类的元素类型（Element Type），最终是要靠类加载器去创建。 验证 文件格式验证 1). 比如是否以魔术0xcafebabe开头。 2). 主、次版本号是否在当前Java虚拟机接收范围之内。 3). 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 元数据验证 1). 这个类是否有父类（除了Object之外，所有的类都有父类） 2). 这个父类的父类是否继承了不允许被继承的类（final修饰的类） 3). 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 这一阶段主要是对类的元数据信息进行语义校验，保证不存在与Java语义规范定义相悖的元数据信息。 字节码验证 主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。例如： 1234567891011保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全 的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。 符号引用验证 符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。 本阶段通常需要校验下列内容： 123456789·符号引用中通过字符串描述的全限定名是否能找到对应的类。 ·在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 ·符号引用中的类、字段、方法的可访问性（private、protected、public、&lt;package&gt;）是否可被当 前类访问。 ·…… 符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常，典型的如： java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等。 准备准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。如果一个类变量被final修饰，那么这个时候赋的初始值就是实际定义的值，比如下面定义的一个变量，那么这个时候在准备阶段就会被赋值为123。 1public static final int value = 123; 解析解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。 直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。 初始化进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：初始化阶段就是执行类构造器()方法的过程。()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及 ()方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作。 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。 ()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成()方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 ()方法。但接口与类不同的是，执行接口()方法不需要先执行父接口的()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的()方法。 Java虚拟机必须保证一个类的()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的()方法，其他线程都需要阻塞等待，直到活动线程执行完毕()方法。如果在一个类的()方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 参考 深入理解Java虚拟机（第3版）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理和动态代理]]></title>
    <url>%2F2020%2F06%2F06%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[什么是代理代理是为其它对象提供一种代理以控制这个对象的访问，Java中的代理分为下面三种角色： Subject（抽象角色）： 通过接口或抽象类声明真实角色实现的业务方法。 RealSubject（目标角色）： 实现抽象角色，定义目标角色所要实现的业务逻辑，供代理角色调用。 Proxy（代理角色）： 实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 代理模式根据生成代理类时机的不同分为两种，分为静态代理和动态代理，静态代理在编译期就已经生成代理类，动态代理是在程序运行的时候动态生成代理类。 静态代理静态代理要求委托类（RealSubject）和代理角色（Proxy）必须实现同一个接口或者继承同一个父类，否则无法生成代理类。 抽象角色123public interface Action &#123; void doSomething();&#125; 目标角色123456public class RealObject implements Action &#123; @Override public void doSomething() &#123; System.out.println("do something"); &#125;&#125; 代理角色123456789101112131415public class ProxyObject implements Action &#123; private Action realObject; public ProxyObject(Action realObject) &#123; this.realObject = realObject; &#125; @Override public void doSomething() &#123; // 自定义代理类的逻辑 System.out.println("proxy do"); // 调用被代理类的方法 realObject.doSomething(); &#125;&#125; 测试类1234567891011public class StaticProxyTest &#123; public static void main(String[] args) &#123; // 被代理对象 Action realObject = new RealObject(); // 代理对象 Action proxyObject = new ProxyObject(realObject); proxyObject.doSomething(); &#125;&#125; 运行结果12proxy dodo something 动态代理动态代理相比静态代理来说，它在一定程度上减少了代码冗余，它通过反射机制来创建代理类。它不要求委托类和代理类必须实现同一个接口或者继承同一个父类，但是委托类需要实现接口，代理类需要实现InvocationHandler接口。JDK动态代理主要涉及到两个类：java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler。比如说我们要代理同一个接口的不同实现，如果使用静态代理，我们就要生成多个代理类，而使用动态代理我们只需要一个代理类。 JDK动态代理抽象角色12345public interface UserDao &#123; void save(); Integer count();&#125; 目标角色12345678910111213public class UserDaoImpl implements UserDao &#123; @Override public void save() &#123; System.out.println("----已经保存数据!----"); &#125; @Override public Integer count() &#123; Integer randomNum = new Random().nextInt(10000); System.out.println("方法正在执行 - totalNum = " + randomNum); return randomNum; &#125;&#125; 代理角色12345678910111213141516171819202122232425262728293031323334public class JdkProxy implements InvocationHandler &#123; /** * 需要代理的目标对象 */ private Object targetObject; public JdkProxy(Object targetObject) &#123; this.targetObject = targetObject; &#125; public Object newProxy(Object targetObject) &#123; this.targetObject = targetObject; return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; before(); // 调用被代理对象的方法 Object returnValue = method.invoke(targetObject, args); after(); return returnValue; &#125; private void after() &#123; System.out.println("方法执行后"); &#125; private void before() &#123; System.out.println("方法执行前"); &#125;&#125; 测试类12345678public class JdkDynamicProxyTest &#123; public static void main(String[] args) &#123; UserDao target = new UserDaoImpl(); UserDao proxy = (UserDao) new ProxyFactory(target).getProxyInstance(); proxy.save(); &#125;&#125; 运行结果123方法执行前----已经保存数据!----方法执行后 CGLIB动态代理Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口。它通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的拦截。使用CGLIB需要引入如下jar包。CGLIB代理方式不要求委托类必须实现接口或者继承一个父类，它通过继承委托类来实现代理，所以这也是它的一个缺点，它不能代理被final修饰的类。 12345678910&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-all&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt;&lt;/dependency&gt; 目标角色123456public class CglibDelegateClass &#123; public String test() &#123; System.out.println("我是委托类"); return UUID.randomUUID().toString(); &#125;&#125; 代理角色12345678910111213141516171819202122232425262728293031323334public class CglibProxyClass implements MethodInterceptor &#123; private Object object; public CglibProxyClass(Object o) &#123; this.object = o; &#125; public Object getProxy()&#123; //1.工具类 Enhancer enhancer = new Enhancer(); //2.设置父类 enhancer.setSuperclass(object.getClass()); //3.设置回调函数 enhancer.setCallback(this); //4.创建子类(代理对象) Object object = enhancer.create(); return object; &#125; public void before() &#123; System.out.println("before"); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; before(); Object object = methodProxy.invokeSuper(o, objects); after(); return object; &#125; public void after() &#123; System.out.println("after"); &#125;&#125; 测试类123456public class CglibTest &#123; public static void main(String[] args) &#123; CglibDelegateClass cglibDelegateClass = (CglibDelegateClass) new CglibProxyClass(new CglibDelegateClass()).getProxy(); cglibDelegateClass.test(); &#125;&#125; 运行结果123before我是委托类after 参考 Java中的静态代理和动态代理 设计模式之代理模式（Proxy Pattern）]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编译与反编译之javac,javap,jad]]></title>
    <url>%2F2020%2F06%2F01%2FJava%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8Bjavac%2Cjavap%2Cjad%2F</url>
    <content type="text"><![CDATA[什么是编译 利用编译程序从源语言编写的源程序产生目标程序的过程。 用编译程序产生目标程序的动作。 编译就是把高级语言变成计算机可以识别的2进制语言，计算机只认识1和0，编译程序把人们熟悉的语言换成2进制的。 编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：词法分析；语法分析；语义检查和中间代码生成；代码优化；目标代码生成。主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。 什么是反编译计算机软件反向工程（Reverse engineering）也称为计算机软件还原工程，是指通过对他人软件的目标程序（比如可执行程序）进行“逆向分析、研究”工作，以推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素，某些特定情况下可能推导出源代码。反编译作为自己开发软件时的参考，或者直接用于自己的软件产品中。 Java中的编译与反编译有时候我们想要查看class文件的具体内容，这个时候我们就需要借助反编译。还有现在越来越多的语法糖被加入到JDK当中，有时候我们想要知道一些具体实现细节，这个时候也需要用到反编译。 编译javacjavac 是java语言编程编译器。全称java compiler。javac工具读由java语言编写的类和接口的定义，并将它们编译成字节代码的class文件。javac 可以隐式编译一些没有在命令行中提及的源文件。用 -verbose 选项可跟踪自动编译。当编译源文件时，编译器常常需要它还没有识别出的类型的有关信息。对于源文件中使用、扩展或实现的每个类或接口，编译器都需要其类型信息。这包括在源文件中没有明确提及、但通过继承提供信息的类和接口。 123456789101112131415161718192021222324252627282930313233用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:&#123;lines,vars,source&#125; 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:&#123;none,only&#125; 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:&#123;none,class&#125; 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名 编译一个java文件，可以看到当前目录下生成了一个Test.class文件。 javac Test.java 如果这个时候我们只有Test.class文件，想要去看到源码，那么我们可以借助反编译工具来实现。 反编译javapjavap是JDK给我们提供的一个反编译工具，通过反编译class文件，我们可以看到这个class文件对应的源代码。 12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 我们可以使用javap Test.class命令来对class文件来进行反编译，反编译后的结果如下： 12345Compiled from &quot;Test.java&quot;public class Test &#123; public Test(); public static void main(java.lang.String[]);&#125; 一般常用的参数是 -v, -l, -c这三个。 javap -v Test.class 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Classfile /E:/software/myBlog/Test.class Last modified 2020-6-1; size 414 bytes MD5 checksum 9746d84e1b97a63d6d5ca7b70d7961f0 Compiled from &quot;Test.java&quot;public class Test minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // Hello World! #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // Test #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 Test.java #15 = NameAndType #7:#8 // &quot;&lt;init&gt;&quot;:()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 Hello World! #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 Test #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V&#123; public Test(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 3: 0 line 4: 8&#125;SourceFile: &quot;Test.java&quot; javap -c Test.class 结果： 123456789101112131415Compiled from &quot;Test.java&quot;public class Test &#123; public Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String Hello World! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return&#125; javac -l Test.class 结果： 1234567891011Compiled from &quot;Test.java&quot;public class Test &#123; public Test(); LineNumberTable: line 1: 0 public static void main(java.lang.String[]); LineNumberTable: line 3: 0 line 4: 8&#125; jad我们可以使用 jad Test.class 来反编译Test.class，会生成一个jad文件，输出结果如下： 12345678910111213141516171819// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.// Jad home page: http://www.kpdus.com/jad.html// Decompiler options: packimports(3) // Source File Name: Test.javaimport java.io.PrintStream;public class Test&#123; public Test() &#123; &#125; public static void main(String args[]) &#123; System.out.println("Hello World!"); &#125;&#125; 参考 javac oracle官方文档 javap oracle官方文档 JVM指令集]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Major GC和Full GC的区别]]></title>
    <url>%2F2020%2F05%2F30%2FMajor%20GC%E5%92%8CFull%20GC%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在周志明的深入理解Java虚拟机第二版这本书里对GC描述有这么一段话。 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也非常快。 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随着至少一次Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC 的速度一般会比Minor GC慢10倍以上。 这里对GC的分类其实有一点问题，Major/FullGC并不一定仅仅只发生在老年代，对于HotSpot VM来说，它里面的GC其实只分为两大种。 Partial GC: 并不收集整个堆的模式 Young GC/Minor GC:只收集新生代的GC OId GC:只收集老年代的GC。目前只有CMS的Concurrent collection是这个模式。 Mixed GC:收集整个新生代以及部分老年代的GC，目前只有G1有这个模式。 Full GC：收集整个堆，包括新生代，老年代、永久代（如果存在的话）等所有部分的模式。 Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。 最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是： young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。 full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。 参考 Major GC和Full GC的区别是什么？触发条件呢？ Java Garbage Collection Basics]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM动态对象年龄判定]]></title>
    <url>%2F2020%2F05%2F28%2FJVM%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[在深入理解Java虚拟机这本书里有这么一句话。 虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 这句话的意思就是如果Survivor区中相同年龄的对象的大小超过了Survivor空间的一半，然后这个年龄再和我们设置的MaxTenuringThreshold（默认值15）晋升年龄阈值进行比较，两者取最小值，大于或等于此年龄的对象将会晋升到老年代。 但是呢，如果碰到下面这种情况，如果非得等到相同年龄对象的大小大于Survivor空间的一半才能晋升，就会导致Survivor空间被占满，但是无法晋升的问题。 MaxTenuringThreshold设置为15 年龄1的对象占Survivor空间的33% 年龄2的对象占Survivor空间的33% 年龄3的对象占Survivor空间的34% 此时Survivor空间中的对象年龄最大的是3，不满足MaxTenuringThreshold，所以无法晋升到老年代。 每个年龄的对象占用都不超过50%，所以也无法晋升到老年代。但是实际上Survivor空间已经被占满。 但是实际上JVM碰到此种情况，还是会让一部分对象晋升到老年代。这个时候JVM又是怎么计算晋升对象的年龄？ -XX:TargetSurvivorRatio 目标存活率，默认为50% 通过这个比例来计算一个期望值，desired_survivor_size 。 然后用一个total计数器，累加每个年龄段对象大小的总和。 当total大于desired_survivor_size 停止。 然后用当前age和MaxTenuringThreshold 对比找出最小值作为结果。 总体JVM的表现就是年龄从小到大进行累加，当Survivor空间中新加入某个年龄段的对象时，累加超过Survivor区域大小*TargetSurvivorRatio的时候。大于或等于此年龄的对象将会晋升到老年代。下图刚好反映了此过程（-XX:+PrintTenuringDistribution输出对象年龄分布） 参考 jvm误区-动态对象年龄判定]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>GC</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾收集]]></title>
    <url>%2F2020%2F05%2F24%2FJVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[如何判断一个对象是否可以被回收 引用计数算法 给对象添加一个引用计数器，当对象增加一个引用的时候计数器加1，引用失效的时候计数器减1。当引用计数为0的时候证明对象可以被回收。但是如果存在循环引用的情况下，会导致对象永远不能被回收。看下面的例子。 12345678910111213public class Test &#123; public Object ins = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.ins = b; b.ins = a; a = null; b = null; &#125;&#125; 此时虽然去除了a对象和b对象的引用，但是两个对象之间还是存在互相引用，这样就导致a、b两个对象无法被回收，但实际上这两个对象已经无法被访问。 可达性分析算法 这个算法的基本原理就是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点向下开始搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明对象无法被访问了。 在Java语言中，可以作为GC Roots的对象包括下面几种 虚拟机栈（栈帧中的本地变量表）引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象 引用类型无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 强引用 被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 软引用 被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 弱引用 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 虚引用 又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 垃圾收集算法标记-清除算法 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 复制算法 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 标记-整理算法 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 分代收集算法现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 垃圾收集器垃圾收集器是内存回收算法具体实现，JVM为我们提供了多种垃圾收集器，不同垃圾收集器有着不同的垃圾回收效果。下面简单介绍一下JVM的垃圾收集器。我们知道Java运行时数据区域分为程序计数器、虚拟机栈、本地方法栈、堆、方法区（JDK1.8用元空间来替代方法区）。垃圾回收主要就发生在堆内存中。堆内存又分为新生代和老年代，默认比例是1:2，即新生代占1/3，老年代占用2/3。可以通过-XX:NewRatio=2参数设置新生代和老年代的比例。新生代又包括Eden和两个Survivor区（SurvivorFrom和SurvivorTo）,一般来说新创建的对象都会在Eden区，少部分进入老年代。SurvivorFrom存放的是上一次GC后存活的对象（再次发生GC之后仍然存活的会被移动到SurvivorTo，年龄加1，达到年龄阈值的会被移动到老年代（年龄阈值默认15，CMS默认6，参考Oracle官方文档，通过 -XX:MaxTenuringThreshold=threshold可以设置）否则会被移动到到老年代，然后From和To会交换，即From-&gt;To，To-&gt;From），SurvivorTo存放的这一次GC之后存活的对象，而这一切工作都是垃圾收集器来帮我们完成的，不需要我们手动去管理内存。下图展示了各种垃圾收集器之间的搭配关系。 Serial收集器Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。它是一个单线程收集器。它的 单线程的意义不仅仅意味着它只会使用一个垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其它所有的工作线程（也就是Stop The World），直到它收集结束。 Serial收集器由于没有线程交互的开销，可以获得较高的单线程收集效率，适合运行在Client模式下的虚拟机。 -XX:+UseSerialGC（使用Serial + Serial Old来进行垃圾回收） ParNew收集器ParNew收集器其实就是 Serial收集器的多线程版本，除了使用多线程进行垃圾收集以外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。 1-XX:+UseParNewGC（使用ParNew + Serial Old的收集器组合进行垃圾回收。） 它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。 Parallel Scavenge收集器Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew一样。它是JDK1.7和JDK1.8的默认新生代垃圾收集器。 1-XX:+UseParallelGC（使用`Parallel Scavenge + Serial Old（PS MarkSweep）`的收集器组合进行垃圾收集。） Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Serial Old收集器Serial 收集器的老年代版本，它是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。需要注意的是，没有直接的参数可以开启Serial Old收集器，只能通过UseSerialGC、UseParallelGC、UseConcMarkSweepGC、UseParNew开启。 Parallel Old 收集器Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。它是JDK1.7和JDK1.8默认的老年代收集器。 1-XX:+UseParallelOldGC（使用Parallel Scavenge + Parallel Old的组合进行垃圾回收。） CMS 收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。 从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点： 对 CPU 资源敏感； 无法处理浮动垃圾； 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。 1CMS: -XX:+UseConcMarkSweepGC -XX:+UseParNewGC（使用ParNew + CMS + Serial Old进行垃圾回收） CMS垃圾收集器不能像其它垃圾收集器一样等到老年代几乎被占满了再进行垃圾收集，需要预留一部分内存空间并发收集时的用户线程使用，因为在垃圾收集阶段，用户线程还是继续在运行的，如果预留的内存空间无法满足需要，那么就会出现一次 Concurrent Mode Failure 失败。这时虚拟机将启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就比较长了。这里需要注意的是 -XX:CMSInitiatingOccupancyFraction 参数设置的太高容易导致Concurrent Mode Failure。性能反而降低。 G1收集器G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征，在JDK1.9中默认启用。 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。 分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。 空间整合：与 CMS 的“标记–清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。 G1 收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 1-XX:+UseG1GC 内存分配与回收策略内存分配策略 对象一般分配在新生代。 当Eden空间不足时，发起Young GC（Minor GC），这里需要注意的是，Young GC也会造成Stop The World。 大对象直接进入老年代。 大对象是指需要连续内存空间的对象，比如说很长的数组以及字符串。如果老年代剩余空间不足以存放大对象，那么会触发一次垃圾收集以获取足够的空间分配给大对象。我们可以设置一个阈值-XX:PretenureSizeThreshold，大于这个值的对象直接在老年代分配。 长期存活的对象进入老年代。 对象经过多次GC之后依然存活，相应的年龄也会增加，增加到一定年龄则晋升到老年代。我们可以通过 -XX:MaxTenuringThreshold来设置晋升的阈值。 动态对象年龄判定。 有时候可能出现未达到晋升年龄，但是Survivor空间已经满了，这个时候如果Survivor空间中相同年龄对象的大小大于Survivor空间的一半，那么大于或等于该年龄的对象直接进入老年代，但是有时候，可能所有某个年龄的对象的大小都没有超过Survivor空间的一半，这个时候其实Survivor空间已经被占满。 JVM碰到这种情况，还是会让一部分对象晋升到老年代，有这么一个参数 -XX:TargetSurvivorRatio，目标存活率，默认是50%。总体JVM的表现就是年龄从小到大进行累加，当Survivor空间中新加入某个年龄段的对象时，累加超过Survivor区域大小*TargetSurvivorRatio的时候。大于或等于此年龄的对象将会晋升到老年代。 空间分配担保 在发生Young GC的时候，JVM会先检查老年代最大连续可用的内存空间是否大于新生代所有对象总空间，如果条件成立的话，那么此次Young GC是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 Full GC触发条件 调用 System.gc()，jmap -histo:live，heap dump命令 System.gc()建议虚拟机执行垃圾回收，不一定真的执行。 老年代空间不足 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 空间分配担保失败 发生Young GC的时候，需要老年代空间作为担保，如果老年代的内存空间大小小于此次将要回收的对象大小，那么会发生一次Full GC。 JDK 1.7 及以前的永久代空间不足或者元空间不足 系统中加载的类，反射的类或者调用的方法太多，永久代或者元空间会被占满。 Concurrent Mode Failure 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 参考 JVM full GC的奇怪现象，求解惑？ Major GC和Full GC的区别是什么？触发条件呢？]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis一级缓存和二级缓存]]></title>
    <url>%2F2020%2F05%2F12%2FMyBatis%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[MyBatis有多种提高查询效率的方法，比如说懒加载、缓存。MyBatis为我们提供了一级缓存和二级缓存。其中一级缓存是默认开启的，二级缓存需要我们自己去Mapper文件里配置。 一级缓存一级缓存是SqlSession级别的，而且是默认开启的（但是这里需要注意的是MyBatis和Spring整合之后，一级缓存就会失效，每调用一次Mapper里的方法，就会重新创建一个SqlSession）。也就是说在同一个SqlSession里，相同的查询语句，第一次查询的结果会被缓存（PerpetualCache，缓存默认的实现类，包括一级缓存和二级缓存），后面的查询会直接从缓存里取数据。一级缓存里存的是上一次查询的对象，两个对象是完全相同的。 代码示例11234567891011121314// 一级缓存默认开启,sqlsession级别SqlSession sqlSession = sqlSessionFactory.openSession();MessageDao messageDao1 = sqlSession.getMapper(MessageDao.class);MessageDao messageDao2 = sqlSession.getMapper(MessageDao.class);// 第一次查询，会发出sql语句，并将查询的结果放入缓存中Message message1 = messageDao1.selectByPrimaryKey(2);Message message2 = messageDao2.selectByPrimaryKey(2);log.info("第一次查询结果 message1 = &#123;&#125;", message1);log.info("第二次查询结果 message2 = &#123;&#125;", message2);sqlSession.close();SqlSession sqlSession1 = sqlSessionFactory.openSession();MessageDao messageDao3 = sqlSession1.getMapper(MessageDao.class);Message message3 = messageDao3.selectByPrimaryKey(2);log.info("第三次查询结果 message3 = &#123;&#125;", message3); 运行结果1 从运行结果可以看出，同一个SqlSession里，第一次查询的时候会把缓存数据，第二次查询的时候并没有去数据库里查询。不同的SqlSession之间缓存是不共享的。 代码示例212345678910111213141516// 一级缓存默认开启,sqlsession级别SqlSession sqlSession = sqlSessionFactory.openSession();MessageDao messageDao1 = sqlSession.getMapper(MessageDao.class);MessageDao messageDao2 = sqlSession.getMapper(MessageDao.class);// 第一次查询，会发出sql语句，并将查询的结果放入缓存中Message message1 = messageDao1.selectByPrimaryKey(2);log.info("第一次查询结果 message1 = &#123;&#125;", message1);messageDao1.updateByPrimaryKey(2);log.info("更新了数据");Message message2 = messageDao2.selectByPrimaryKey(2);log.info("第二次查询结果 message2 = &#123;&#125;", message2);sqlSession.close();sqlSession = sqlSessionFactory.openSession();MessageDao messageDao3 = sqlSession.getMapper(MessageDao.class);Message message3 = messageDao3.selectByPrimaryKey(2);log.info("第三次查询结果 message3 = &#123;&#125;", message3); 运行结果2 二级缓存二级缓存默认是不开启的，并且二级缓存是基于 mapper 中的 namespace 的，也就是说就算是不同的sqlSession,如果namespace相同，那么还是可以共享缓存的。 开启二级缓存 设置 cacheEnable 属性值为 true 在对应的mapper xml文件里添加 &lt;cache /&gt;标签，PerpetualCache 是mybatis提供的默认缓存实现类，内部数据结构是HashMap。 12&gt; &lt;cache type="org.apache.ibatis.cache.impl.PerpetualCache"&gt;&lt;/cache&gt;&gt; 代码示例1234567891011121314151617181920212223242526// 二级缓存默认不开启，需要去手动开启SqlSession sqlSession1 = sqlSessionFactory.openSession();SqlSession sqlSession2 = sqlSessionFactory.openSession();SqlSession sqlSession3 = sqlSessionFactory.openSession();MessageDao messageDao1 = sqlSession1.getMapper(MessageDao.class);MessageDao messageDao2 = sqlSession2.getMapper(MessageDao.class);MessageDao messageDao3 = sqlSession3.getMapper(MessageDao.class);// 第一次查询，会发出sql语句，并将查询的结果放入缓存中Message message1 = messageDao1.selectByPrimaryKey(2);// 需要提交之后二级缓存才会生效log.info("message1 = &#123;&#125;", message1);sqlSession1.commit();Message message2 = messageDao2.selectByPrimaryKey(2);log.info("message2 = &#123;&#125;", message2);Message message3 = messageDao3.selectByPrimaryKey(2);log.info("message3 = &#123;&#125;", message3);// sqlSession1.close();// 修改数据，如果这里的 flushCache 属性值为 false ，那么会造成脏读，默认这个属性是为true的// 一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。所以我们不用设置，默认即可messageDao3.updateByPrimaryKey(2);sqlSession3.commit();// // 第二次查询，即使sqlSession1已经关闭了，这次查询依然不发出sql语句message2 = messageDao2.selectByPrimaryKey(2);log.info("message2 = &#123;&#125;", message2); 运行结果 从上面的运行结果可以看出，二级缓存开启之后，messageDao2,messageDao3这两次查询都是从缓存里面去查找数据的，缓存命中率分别为0.5和0.66666666。sqlSession3修改数据之后并且commit，可以发现messageDao2并没有从缓存里面取出数据，而是从数据库里获取数据。 如何关闭一级缓存 设置localCacheScope 为 STATEMENT 级别，默认是SESSION级别。 设置 flushCache 为 true。 参考资料 https://zhuanlan.zhihu.com/p/37260121 https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache https://blog.csdn.net/ctwy291314/article/details/81938882]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM监控和常用命令]]></title>
    <url>%2F2020%2F05%2F10%2FJVM%E7%9B%91%E6%8E%A7%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Java应用程序在运行的时候可能会出现莫名的卡顿，CPU使用率很高等情况，这个时候我们需要定位问题，就需要使用到JVM的一些命令和工具。下面总结了我们在排查问题的时候经常使用的命令和工具（基于JDK1.8）。 常用命令jstack123456789101112131415Usage: jstack [-l] &lt;pid&gt; (to connect to running process) jstack -F [-m] [-l] &lt;pid&gt; (to connect to a hung process) jstack [-m] [-l] &lt;executable&gt; &lt;core&gt; (to connect to a core file) jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt; (to connect to a remote debug server)Options: -F to force a thread dump. Use when jstack &lt;pid&gt; does not respond (process is hung) -m to print both java and native frames (mixed mode) -l long listing. Prints additional information about locks -h or -help to print this help message 官方文档 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html 打印线程栈日志(-l 表示打印出关于锁的额外信息) jstack -l pid jinfo12345678910111213141516Usage: jinfo [option] &lt;pid&gt; (to connect to running process) jinfo [option] &lt;executable &lt;core&gt; (to connect to a core file) jinfo [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: -flag &lt;name&gt; to print the value of the named VM flag -flag [+|-]&lt;name&gt; to enable or disable the named VM flag -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value -flags to print VM flags -sysprops to print Java system properties &lt;no option&gt; to print both of the above -h | -help to print this help message 官方文档 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html#BCGEBFDD 查看某个Java进程设置的最大堆内存 jinfo -flag MaxHeapSize pid -XX:MaxHeapSize=482344960(字节) 查看某个Java进程设置的所有参数 jinfo -flags pid 查看Java系统属性 Jinfo -sysprops pid = 表示默认值 := 被用户或者JVM修改后的值 比如： bool UseG1GC = false // =表示默认值 uintx MaxNewSize := 160759808 // :=表示被用户或jvm修改后的值 Non-default VM flags: 被手动赋值的参数，有的是自己设的（比如使用jinfo命令动态设置参数），有的是tomcat的shell脚本里tomcat设置的 jmap12345678910111213141516171819202122232425262728Usage: jmap [option] &lt;pid&gt; (to connect to running process) jmap [option] &lt;executable &lt;core&gt; (to connect to a core file) jmap [option] [server_id@]&lt;remote server IP or hostname&gt; (to connect to remote debug server)where &lt;option&gt; is one of: &lt;none&gt; to print same info as Solaris pmap -heap to print java heap summary -histo[:live] to print histogram of java object heap; if the "live" suboption is specified, only count live objects -clstats to print class loader statistics -finalizerinfo to print information on objects awaiting finalization -dump:&lt;dump-options&gt; to dump java heap in hprof binary format dump-options: live dump only live objects; if not specified, all objects in the heap are dumped. format=b binary format file=&lt;file&gt; dump heap to &lt;file&gt; Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt; -F force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo to force a heap dump or histogram when &lt;pid&gt; does not respond. The "live" suboption is not supported in this mode. -h | -help to print this help message -J&lt;flag&gt; to pass &lt;flag&gt; directly to the runtime system 官方文档 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html#CEGCECJB 查看某个Java进程的内存映像信息 jmap pid 1234567891011121314151617181920Attaching to process ID 32325, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.131-b110x0000000000400000 7K /usr/java/jdk/jdk1.8.0_131/bin/java0x00007f75a11a8000 90K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libnio.so0x00007f75a13b9000 49K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libmanagement.so0x00007f75a18c2000 113K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libnet.so0x00007f75c87f9000 121K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libzip.so0x00007f75c8a14000 60K /usr/lib64/libnss_files-2.17.so0x00007f75c8c27000 220K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libjava.so0x00007f75c8e53000 64K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/libverify.so0x00007f75c9061000 43K /usr/lib64/librt-2.17.so0x00007f75c9269000 1114K /usr/lib64/libm-2.17.so0x00007f75c956b000 16597K /usr/java/jdk/jdk1.8.0_131/jre/lib/amd64/server/libjvm.so0x00007f75ca55e000 2062K /usr/lib64/libc-2.17.so0x00007f75ca920000 19K /usr/lib64/libdl-2.17.so0x00007f75cab24000 100K /usr/java/jdk/jdk1.8.0_131/lib/amd64/jli/libjli.so0x00007f75cad3a000 138K /usr/lib64/libpthread-2.17.so0x00007f75caf56000 160K /usr/lib64/ld-2.17.so 使用不带选项参数的jmap打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。 显示Java堆详细信息 jmap -heap pid 打印一个堆的摘要信息，包括使用的GC算法、堆配置信息和各内存区域内存使用信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Attaching to process ID 32325, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.131-b11using thread-local object allocation.Mark Sweep Compact GCHeap Configuration: MinHeapFreeRatio = 40 MaxHeapFreeRatio = 70 MaxHeapSize = 482344960 (460.0MB) NewSize = 10485760 (10.0MB) MaxNewSize = 160759808 (153.3125MB) OldSize = 20971520 (20.0MB) NewRatio = 2 SurvivorRatio = 8 MetaspaceSize = 21807104 (20.796875MB) CompressedClassSpaceSize = 1073741824 (1024.0MB) MaxMetaspaceSize = 17592186044415 MB G1HeapRegionSize = 0 (0.0MB)Heap Usage:New Generation (Eden + 1 Survivor Space): capacity = 9437184 (9.0MB) used = 3872032 (3.692657470703125MB) free = 5565152 (5.307342529296875MB) 41.02952745225694% usedEden Space: capacity = 8388608 (8.0MB) used = 3835424 (3.657745361328125MB) free = 4553184 (4.342254638671875MB) 45.72181701660156% usedFrom Space: capacity = 1048576 (1.0MB) used = 36608 (0.034912109375MB) free = 1011968 (0.965087890625MB) 3.4912109375% usedTo Space: capacity = 1048576 (1.0MB) used = 0 (0.0MB) free = 1048576 (1.0MB) 0.0% usedtenured generation: capacity = 20971520 (20.0MB) used = 7702632 (7.345802307128906MB) free = 13268888 (12.654197692871094MB) 36.72901153564453% used4864 interned Strings occupying 496072 bytes. 显示堆中对象的统计信息 jmap -histo:live pid 其中包括每个Java类、对象数量、内存大小(单位：字节)、完全限定的类名。打印的虚拟机内部的类名称将会带有一个’*’前缀。如果指定了live子选项，则只计算活动的对象。 打印等待回收的对象信息 jmap -finalizeerinfo pid Number of objects pending for finalization: 0 说明当前F-QUEUE队列中并没有等待Fializer线程执行finalizer方法。 生成堆转储快照 jmap -dump:format=b,file=heapdump.phrof pid 以hprof二进制格式转储Java堆到指定filename的文件中。live子选项是可选的。如果指定了live子选项，堆中只有活动的对象会被转储。想要浏览heap dump，你可以使用jhat(Java堆分析工具), jvisualvm, mat读取生成的文件。这个命令在线上慎用，如果heap比较大的话，就会导致dump比较耗时，并且执行的过程中为了保证dump的信息是可靠的，所以会暂停应用，线上系统慎用。 jstat1234567891011121314151617181920Usage: jstat -help|-options jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]Definitions: &lt;option&gt; An option reported by the -options option &lt;vmid&gt; Virtual Machine Identifier. A vmid takes the following form: &lt;lvmid&gt;[@&lt;hostname&gt;[:&lt;port&gt;]] Where &lt;lvmid&gt; is the local vm identifier for the target Java virtual machine, typically a process id; &lt;hostname&gt; is the name of the host running the target Java virtual machine; and &lt;port&gt; is the port number for the rmiregistry on the target host. See the jvmstat documentation for a more complete description of the Virtual Machine Identifier. &lt;lines&gt; Number of samples between header lines. &lt;interval&gt; Sampling interval. The following forms are allowed: &lt;n&gt;["ms"|"s"] Where &lt;n&gt; is an integer and the suffix specifies the units as milliseconds("ms") or seconds("s"). The default units are "ms". &lt;count&gt; Number of samples to take before terminating. -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system. 官方文档 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html#BEHHGFAE 显示加载 class 的数量，以及所占空间等信息。 jstat -class pid Loaded : 加载class的数量 Bytes : class字节大小 Unloaded : 卸载class的数量 Bytes : 卸载class的字节大小 Time : 加载时间 显示JVM实时编译（JIT）的数量等信息 jstat -compiler pid Compiled : 编译数量 Failed : 编译失败数量 Invalid : 无效数量 Time : 编译耗时 FailedType : 失败类型 FailedMethod : 失败方法的全限定名 查看gc次数，以及时间 jstat -gc pid 1234567891011121314S1C：年轻代中第二个survivor（幸存区）的容量 (KB)S0U ：年轻代中第一个survivor（幸存区）目前已使用空间 (KB)S1U ：年轻代中第二个survivor（幸存区）目前已使用空间 (KB)EC ：年轻代中Eden（伊甸园）的容量 (KB)EU ：年轻代中Eden（伊甸园）目前已使用空间 (KB)OC ：Old代的容量 (KB)OU ：Old代目前已使用空间 (KB)MC：metaspace(元空间)的容量 (KB)MU：metaspace(元空间)目前已使用空间 (KB)YGC ：从应用程序启动到采样时年轻代中gc次数YGCT ：从应用程序启动到采样时年轻代中gc所用时间(s)FGC ：从应用程序启动到采样时old代(全gc)gc次数FGCT ：从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT：从应用程序启动到采样时gc用的总时间(s) 查看JVM内存中对象的使用情况和占用空间大小 jstat -gccapacity pid 123456789101112131415161718NGCMN ：年轻代(young)中初始化(最小)的大小(KB)NGCMX ：年轻代(young)的最大容量 (KB)NGC ：年轻代(young)中当前的容量 (KB)S0C ：年轻代中第一个survivor（幸存区）的容量 (KB)S1C ： 年轻代中第二个survivor（幸存区）的容量 (KB)EC ：年轻代中Eden（伊甸园）的容量 (KB)OGCMN ：old代中初始化(最小)的大小 (KB)OGCMX ：old代的最大容量(KB)OGC：old代当前新生成的容量 (KB)OC ：Old代的容量 (KB)MCMN：metaspace(元空间)中初始化(最小)的大小 (KB)MCMX ：metaspace(元空间)的最大容量 (KB)MC ：metaspace(元空间)当前的容量 (KB)CCSMN：最小压缩类空间大小CCSMX：最大压缩类空间大小CCSC：当前压缩类空间大小YGC ：从应用程序启动到采样时年轻代中gc次数FGC：从应用程序启动到采样时old代(全gc)gc次数 元空间（Metaspace）中对象的信息及其占用空间。 jstat -gcmetacapacity pid 12345678910MCMN:最小元数据容量MCMX：最大元数据容量MC：当前元数据空间大小CCSMN：最小压缩类空间大小CCSMX：最大压缩类空间大小CCSC：当前压缩类空间大小YGC ：从应用程序启动到采样时年轻代中gc次数FGC ：从应用程序启动到采样时old代(全gc)gc次数FGCT ：从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT：从应用程序启动到采样时gc用的总时间(s) 新生代对象相关信息。 jstat -gcnew pid 1234567891011S0C ：年轻代中第一个survivor（幸存区）的容量 (KB)S1C ：年轻代中第二个survivor（幸存区）的容量 (KB)S0U ：年轻代中第一个survivor（幸存区）目前已使用空间 (KB)S1U ：年轻代中第二个survivor（幸存区）目前已使用空间 (KB)TT：持有次数限制MTT：最大持有次数限制DSS：期望的幸存区大小EC：年轻代中Eden（伊甸园）的容量 (KB)EU ：年轻代中Eden（伊甸园）目前已使用空间 (KB)YGC ：从应用程序启动到采样时年轻代中gc次数YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) 新生代对象的信息以及占用空间 jstat -gcnewcapacity pid 1234567891011NGCMN ：年轻代(young)中初始化(最小)的大小(KB)NGCMX ：年轻代(young)的最大容量 (KB)NGC ：年轻代(young)中当前的容量 (KB)S0CMX ：年轻代中第一个survivor（幸存区）的最大容量 (KB)S0C ：年轻代中第一个survivor（幸存区）的容量 (KB)S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (KB)S1C：年轻代中第二个survivor（幸存区）的容量 (KB)ECMX：年轻代中Eden（伊甸园）的最大容量 (KB)EC：年轻代中Eden（伊甸园）的容量 (KB)YGC：从应用程序启动到采样时年轻代中gc次数FGC：从应用程序启动到采样时old代(全gc)gc次数 老年代对象的信息 jstat -gcold pid 12345678910MC ：metaspace(元空间)的容量 (KB)MU：metaspace(元空间)目前已使用空间 (KB)CCSC:压缩类空间大小CCSU:压缩类空间使用大小OC：Old代的容量 (KB)OU：Old代目前已使用空间 (KB)YGC：从应用程序启动到采样时年轻代中gc次数FGC：从应用程序启动到采样时old代(全gc)gc次数FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT：从应用程序启动到采样时gc用的总时间(s) 老年代对象信息及其占用空间 jstat -gcoldcapacity pid 12345678OGCMN ：old代中初始化(最小)的大小 (KB)OGCMX ：old代的最大容量(KB)OGC ：old代当前新生成的容量 (KB)OC ：Old代的容量 (KB)YGC ：从应用程序启动到采样时年轻代中gc次数FGC ：从应用程序启动到采样时old代(全gc)gc次数FGCT ：从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT：从应用程序启动到采样时gc用的总时间(s) 统计gc信息 jstat -gcutil pid jstat -gcutil pid 1000 10 每1s打印一次gc信息，总共打印10次 123456789101112S0 ：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比S1 ：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比E ：年轻代中Eden（伊甸园）已使用的占当前容量百分比O ：old代已使用的占当前容量百分比P ：perm代已使用的占当前容量百分比M: Metaspace utilization as a percentage of the space's current capacity. 元空间CCS: Compressed class space utilization as a percentage. 压缩类空间利用率为百分比。YGC ：从应用程序启动到采样时年轻代中gc次数YGCT ：从应用程序启动到采样时年轻代中gc所用时间(s)FGC ：从应用程序启动到采样时old代(全gc)gc次数FGCT ：从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT：从应用程序启动到采样时gc用的总时间(s) 显示垃圾回收的相关信息，同时显示最后一次或当前正在发生的垃圾回收的诱因。 jstat -gccause pid 12LGCC：最后一次GC原因GCC：当前GC原因（No GC 为当前没有执行GC） 当前jvm执行的信息。 jstat -printcompilation pid 1234Compiled ：编译任务的数目Size ：方法生成的字节码的大小Type：编译类型Method：类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的。 jhat12345678910111213141516171819202122232425Usage: jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt; -J&lt;flag&gt; Pass &lt;flag&gt; directly to the runtime system. For example, -J-mx512m to use a maximum heap size of 512MB -stack false: Turn off tracking object allocation call stack. -refs false: Turn off tracking of references to objects -port &lt;port&gt;: Set the port for the HTTP server. Defaults to 7000 -exclude &lt;file&gt;: Specify a file that lists data members that should be excluded from the reachableFrom query. -baseline &lt;file&gt;: Specify a baseline object dump. Objects in both heap dumps with the same ID and same class will be marked as not being "new". -debug &lt;int&gt;: Set debug level. 0: No debug output 1: Debug hprof file parsing 2: Debug hprof file parsing, no server -version Report version number -h|-help Print this help and exit &lt;file&gt; The file to readFor a dump file that contains multiple heap dumps,you may specify which dump in the fileby appending "#&lt;number&gt;" to the file name, i.e. "foo.hprof#3".All boolean options default to "true" 官方文档 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html#CIHHJAGE jhat是用来分析jmap生成dump文件的命令，jhat内置了应用服务器，可以通过网页查看dump文件分析结果，jhat一般是用在离线分析上。 jhat dump.hprof 访问localhost:7000，所看到的页面如下图所示： jconsole,jvisualvm除了可以使用jhat来分析堆dump文件，也可以使用jconsole，或者jvisualvm来分析。 jconslole官方文档https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jconsole.html#CACCABEH jvisualvm官方文档https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jvisualvm.html#CBBEGDEJ 分析堆dump文件 CPU占用率高： 其它命令 查看JVM所有可设置参数及其值 java -XX:+PrintFlagsFinal -version 命令实战jstack 分析死锁，死循环，CPU高占用率jps -l 获取对应的Java进程的pid。 查看该进程对应的线程状态，输入大写的P即可按照CPU的使用率降序排列。 top -Hp pid 找到CPU使用率最高的线程id，然后把线程id转换为16进制的。 Printf “%x\n” 下面可以通过获取到的线程id来查看栈信息。 Jstack -l pid | grep -30 ‘&lt;16进制的thread id&gt;’ 重点关注一下状态的线程。 123456781) 死锁， Deadlock （重点关注）2) 执行中，Runnable 3) 等待资源，Waiting on condition（重点关注）4) 等待获取监视器，Waiting on monitor entry（重点关注）暂停，Suspended5) 对象等待中，Object.wait() 或 TIMED_WAITING6) 阻塞，Blocked（重点关注，只有synchronized这种方式的锁（monitor锁）才会让线程出现BLOCKED状态，等待ReentrantLock则不会） 7) 停止，Parked（LockSupport两组方法park/parkNanos/parkUntil，使用带参数Object blocker的，jstack输出中会显示更详细的线程信息） 参考 Oracle官方文档]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>监控</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解String intern方法]]></title>
    <url>%2F2019%2F11%2F22%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3String%20intern%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[String类型在Java语言中算是比较特殊的一种类型，它区别于8种基本数据类型（int，short，byte，long，double，float，char，boolean）。这些基本数据类型对应的包装类型大多都提供了常量池（除了Double，Float，常量池范围-128,127，其中Integer可以通过JVM参数-XX:AutoBoxCacheMax调节常量池的范围）。String类型的常量池相对比较特殊，它的使用方法主要有两种。 直接用双引号声明出来的 String对象 会直接分配在存储在字符串常量池里面 如果不是用双引号声明的 String对象，可以调用String对象的intern方法。intern方法会检查字符串常量池里面是否存在当前字符串，如果不存在就会把该字符串存储在常量池里，存在则直接返回该字符串的引用。以下就是JDK1.8中String#intern方法的注释。 12345* When the intern method is invoked, if the pool already contains a* string equal to this &#123;@code String&#125; object as determined by* the &#123;@link #equals(Object)&#125; method, then the string from the pool is* returned. Otherwise, this &#123;@code String&#125; object is added to the* pool and a reference to this &#123;@code String&#125; object is returned. String#intern方法详解它的大体实现结构就是: JAVA 使用 jni 调用c++实现的StringTable的intern方法, StringTable的intern方法跟Java中的HashMap的实现是差不多的, 只是不能自动扩容。默认大小是1009。 要注意的是，String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009，如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降（因为要一个一个找）。 在 jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。在jdk7中，StringTable的长度可以通过一个参数指定： -XX:StringTableSize=99991 相信很多 人都做过类似 String s = new String(&quot;abc&quot;)这个语句创建了几个对象的题目。 这种题目主要就是为了考察对字符串对象的常量池掌握与否。上述的语句中是创建了2个对象，第一个对象是”abc”字符串存储在常量池中，第二个对象在JAVA Heap中的 String 对象。 来看一段代码： 1234567891011public static void main(String[] args) &#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s == s2); String s3 = new String("1") + new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3 == s4);&#125; 打印结果是 jdk6 下false false jdk7 下false true jdk1.6原因： 注：图中绿色线条代表 string 对象的内容指向。 黑色线条代表地址指向。 如上图所示。首先说一下 jdk6中的情况，在 jdk6中上述的所有打印都是 false 的，因为 jdk6中的常量池是放在 Perm 区中的，Perm 区和正常的 JAVA Heap 区域是完全分开的。上面说过如果是使用引号声明的字符串都是会直接在字符串常量池中生成，而 new 出来的 String 对象是放在 JAVA Heap 区域。所以拿一个 JAVA Heap 区域的对象地址和字符串常量池的对象地址进行比较肯定是不 相同的，即使调用String.intern方法也是没有任何关系的。 然后将s3.intern();语句下调一行，放到String s4 = &quot;11&quot;;后面。将s.intern(); 放到String s2 = &quot;1&quot;;后面。是什么结果呢 1234567891011public static void main(String[] args) &#123; String s = new String("1"); String s2 = "1"; s.intern(); System.out.println(s == s2); String s3 = new String("1") + new String("1"); String s4 = "11"; s3.intern(); System.out.println(s3 == s4);&#125; 打印结果为： jdk6 下false false jdk7 下false false jdk1.7原因： 在第一段代码中，先看 s3和s4字符串。String s3 = new String(&quot;1&quot;) + new String(&quot;1&quot;);，这句代码中现在生成了2最终个对象，是字符串常量池中的“1” 和 JAVA Heap 中的 s3引用指向的对象。中间还有2个匿名的new String(&quot;1&quot;)我们不去讨论它们。此时s3引用对象内容是”11”，但此时常量池中是没有 “11”对象的。 接下来s3.intern();这一句代码，是将 s3中的“11”字符串放入 String 常量池中，因为此时常量池中不存在“11”字符串，因此常规做法是跟 jdk6 图中表示的那样，在常量池中生成一个 “11” 的对象，关键点是 jdk7 中常量池不在 Perm 区域了，这块做了调整。常量池中不需要再存储一份对象了，可以直接存储堆中的引用。这份引用指向 s3 引用的对象。 也就是说引用地址是相同的。 最后String s4 = &quot;11&quot;; 这句代码中”11”是显示声明的，因此会直接去常量池中创建，创建的时候发现已经有这个对象了，此时也就是指向 s3 引用对象的一个引用。所以 s4 引用就指向和 s3 一样了。因此最后的比较 s3 == s4 是 true。 再看 s 和 s2 对象。 String s = new String(&quot;1&quot;); 第一句代码，生成了2个对象。常量池中的“1” 和 JAVA Heap 中的字符串对象。s.intern(); 这一句是 s 对象去常量池中寻找后发现 “1” 已经在常量池里了。 接下来String s2 = &quot;1&quot;; 这句代码是生成一个 s2的引用指向常量池中的“1”对象。 结果就是 s 和 s2 的引用地址明显不同。图中画的很清晰。 来看第二段代码，从上边第二幅图中观察。第一段代码和第二段代码的改变就是 s3.intern(); 的顺序是放在String s4 = &quot;11&quot;;后了。这样，首先执行String s4 = &quot;11&quot;;声明 s4 的时候常量池中是不存在“11”对象的，执行完毕后，“11“对象是 s4 声明产生的新对象。然后再执行s3.intern();时，常量池中“11”对象已经存在了，因此 s3 和 s4 的引用是不同的。 第二段代码中的 s 和 s2 代码中，s.intern();，这一句往后放也不会有什么影响了，因为对象池中在执行第一句代码String s = new String(&quot;1&quot;);的时候已经生成“1”对象了。下边的s2声明都是直接从常量池中取地址引用的。 s 和 s2 的引用地址是不会相等的。 总结 从上述的例子代码可以看出 jdk7 版本对 intern 操作和常量池都做了一定的修改。主要包括2点： 将String常量池 从 Perm 区移动到了 Java Heap区 String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。 参考 深入解析String#intern 项目demo]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM GC分析总结]]></title>
    <url>%2F2019%2F09%2F15%2FJVM%20GC%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[FullGC发生的条件 没有配置 -XX:+DisableExplicitGC情况下System.gc()可能会触发FullGC； Promotion failed； concurrent mode failure； Metaspace Space使用达到MaxMetaspaceSize阈值； 执行jmap -histo:live或者jmap -dump:live； 1说明：统计发现之前YGC的平均晋升大小比目前old gen剩余的空间大，触发的是CMS GC；如果配置了CMS，并且Metaspace Space使用量达到MetaspaceSize阈值也是触发CMS GC； 执行jmap -histo:live触发FullGC的gc log如下–关键词Heap Inspection Initiated GC，通过jstat -gccause pid 2s的LGCC列也能看到同样的关键词： 1[Full GC (Heap Inspection Initiated GC) 2018-03-29T15:26:51.070+0800: 51.754: [CMS: 82418K-&gt;55047K(131072K), 0.3246618 secs] 138712K-&gt;55047K(249088K), [Metaspace: 60713K-&gt;60713K(1103872K)], 0.3249927 secs] [Times: user=0.32 sys=0.01, real=0.32 secs] 执行jmap -dump:live触发FullGC的gc log如下–关键词Heap Dump Initiated GC，通过jstat -gccause pid 2s的LGCC列也能看到同样的关键词： 1[Full GC (Heap Dump Initiated GC) 2018-03-29T15:31:53.825+0800: 354.510: [CMS2018-03-29T15:31 什么样的JVM和GC才是正常的？GC是否正常，首先就要看YoungGC，OldGC和FullGC是否正常；无论是定位YoungGC，OldGC，FullGC哪一种GC，判断其是否正常主要从两个维度：GC频率和STW时间；要得到这两个维度的值，我们需要知道JVM运行了多久，执行如下命令即可： 1ps -p pid -o etime 运行结果参考如下，表示这个JVM运行了24天16个小时37分35秒，如果JVM运行时间没有超过一天，执行结果类似这样”16:37:35”： 123[afei@ubuntu ~]$ ps -p 11864 -o etime ELAPSED24-16:37:35 正常的GC需要满足的条件（参考，不一定完全一样） YoungGC频率不超过2秒/次； CMS GC频率不超过1天/次； 每次YoungGC的时间不超过15ms； FullGC频率尽可能完全杜绝； YGCYGC是最频繁发生的，发生的概率是OldGC和FullGC的的10倍，100倍，甚至1000倍。同时YoungGC的问题也是最难定位的。这里给出YGC定位三板斧（都是踩过坑）： 查看服务器SWAP&amp;IO情况，如果服务器发生SWAP，会严重拖慢GC效率，导致STW时间异常长，拉长接口响应时间，从而影响用户体验（推荐神器sar，yum install sysstat即可，想了解该命令，请搜索”linux sar“）； 查看StringTable情况（请参考：探索StringTable提升YGC性能） 排查每次YGC后幸存对象大小（JVM模型基于分配的对象朝生夕死的假设设计，如果每次YGC后幸存对象较大，可能存在问题） OldGC上面已经提及：到目前为止HotSpot JVM虚拟机只单独回收Old区的只有CMS GC。触发CMS GC条件比较简单，JVM有一个线程定时扫描Old区，时间间隔可以通过参数-XX:CMSWaitDuration设置（默认就是2s），扫描发现Old区占比超过参数-XX:CMSInitiatingOccupancyFraction设定值（CMS条件下默认为68%），就会触发CMS GC。建议搭配-XX:+UseCMSInitiatingOccupancyOnly参数使用，简化CMS GC触发条件，只有在Old区占比满足-XX:CMSInitiatingOccupancyFraction条件的情况下才触发CMS GC； 可参考的健康的GC状况给出建议CMS GC频率不超过1天/次，如果CMS GC频率1天发生数次，甚至上10次，说明你的GC情况病的不轻了，建议follow如下步骤进行初步症断： 检查Young区与Old区比值，尽量留60%以上的堆空间给Old区； 通过jstat查看每次YoungGC后晋升到Old区对象占比，如果发现每次YoungGC后Old区涨好几个百分点，甚至上10个点，说明有大对象，建议dump（参考jmap -dump:format=b,file=app.bin pid）后用MAT分析； 如果不停的CMS GC，Old区降不下去，建议先执行jmap -histo pid | head -n10 查看TOP10对象分布，如果除了[B和[C，即byte[]和char[]，还有其他占比较大的实例，如下图所示中排名第一的Object数组，也可通过dump后用MAT分析问题； 如果TOP10对象中有StandartSession对象，排查你的业务代码中有没有显示使用HttpSession，例如String id = request.getSession().getId();，一般的OLTP系统都是无状态的，几乎不会使用HttpSession，且HttpSession的的生命周期很长，会加快Old区增长速度； FullGC如果配置CMS，由于CMS采用标记清理算法，会有内存碎片的问题，推荐配置一个查看内存碎片程度的JVM参数：PrintFLSStatistics。 如果配置ParallelOldGC，那么每次Old区满后，会触发FullGC，如果FullGC频率过高，也可以通过上面OldGC提及的排查方法； 如果没有配置-XX:+DisableExplicitGC，即没有屏蔽System.gc()触发FullGC，那么可以通过排查GC日志中有System字样判断是否由System.gc()触发，日志样本如下： 1558082.666: [Full GC (System) [PSYoungGen: 368K-&gt;0K(42112K)] [PSOldGen: 36485K-&gt;32282K(87424K)] 36853K-&gt;32282K(129536K) [PSPermGen: 34270K-&gt;34252K(196608K)], 0.2997530 secs] 或者通过jstat -gccause pid 2s pid判定，LGCC表示最近一次GC原因，如果为System.gc，表示由System.gc()触发，GCC表示当前GC原因，如果当前没有GC，那么就是No GC： 参考 你的JVM还好吗？GC初步诊断 linux 性能监控 sar命令 深入理解swap交换分区理解及扩存]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM相关]]></title>
    <url>%2F2019%2F09%2F15%2FJVM%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[概述对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。 运行时数据区域Java虚拟机在执行Java程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK1.8和之前的版本略有不同，下面会介绍到。 JDK1.8之前： JDK1.8： 线程私有的： 程序计数器本地方法栈虚拟机栈 线程共享的：堆方法区直接内存（非运行时数据区的一部分） 程序计数器程序计数器时一块较小的内存，可以看做是当前所执行的直字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 程序计数器的两个作用： 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 多线程环境下用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道上次运行的位置。 注意：程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。 Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。） 局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。 Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。 StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。 Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 本地方法栈和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。 堆Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么”绝对”了。 ava 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。 上图所示的 eden 区、s0 区、s1 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。 方法区方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。方法区也被称为永久代。 方法区和永久代的关系 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。 常用参数JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小 -XX:PermSize=N //方法区 (永久代) 初始大小-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen 相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。 下面是一些常用参数： -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小 与永久代很大的不同就是，如果不指定元空间大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。 为什么要将永久代（PermGen）替换为元空间呢（MetaSpace）呢整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到 java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。 运行时常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。JDK1.4 中新加入的 NIO(New Input/Output) 类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 HotSpot 虚拟机对象探秘下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。 下图就是Java对象的创建过程。要重点掌握，并且能默写出来。 类加载检查 虚拟机遇到一条new指令的时候，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 TLAB： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 初始化零值 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行 init 方法 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 垃圾收集判断一个对象是否可被回收 引用计数算法 可达性分析算法 方法区的回收 finalize() 引用类型 强引用 软引用 弱引用 虚引用 垃圾收集算法 标记 - 清除 标记 - 整理 复制 分代收集 垃圾收集器 Serial 收集器 ParNew 收集器 Parallel Scavenge 收集器 Serial Old 收集器 Parallel Old 收集器 CMS 收集器 G1收集器 内存分配与回收策略Minor GC 和 Full GC 内存分配策略 对象优先在Eden分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 空间分配担保 Full GC 的触发条件 调用System.gc() 老年代空间不足 空间分配担保失败 JDK1.7及以前的永久带空间不足 Concurrent Mode Failure 类加载机制类的生命周期 类加载过程 加载 验证 准备 解析 初始化 类初始化时机 主动引用 被动引用 类与类加载器 类加载器分类 双亲委派模型 工作过程 好处 实现 自定义类加载器实现 参考资料todo]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz使用]]></title>
    <url>%2F2019%2F09%2F13%2FQuartz%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Quartz 简介Quartz是OpenSymphony在Job Scheduling 领域的又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建简单或为运行十个，百个，甚至是好几万个Jobs这样复杂的程序。Jobs可以做成标准的Java组件或 EJBs。 Quartz核心概念调度器（Scheduler）Quartz框架的核心是调度器。调度器负责管理Quartz应用运行时环境。调度器不是靠自己做所有的工作，而是依赖框架内一些非常重要的部件。Quartz不仅仅是线程和线程管理。为确保可伸缩性，Quartz采用了基于多线程的架构。启动时，框架初始化一套worker线程，这套线程被调度器用来执行预定的作业。这就是Quartz怎样能并发运行多个作业的原理。Quartz依赖一套松耦合的线程池管理部件来管理线程环境。 任务（Job）Job接口非常容易实现，只有一个execute方法，类似TimerTask的run方法，在里面编写业务逻辑Job实例在Quartz中的生命周期每次调度器（Scheduler）执行job时，它在调用execute方法前会创建一个新的job实例。当调用完成后，关联的job对象实例会被释放，释放的实例会被垃圾回收机制回收 触发器Quartz中的触发器用来告诉调度程序作业什么时候触发。即Trigger对象时用来触发执行Job的。主要了解CronTriggerImpl和SimpleTriggerImpl。 trigger触发器通用属性JobKey表示job实例的标识，触发器被触发时，该指定的job实例会执行 StartTime表示触发器的时间表首次被触发的时间，它的值的类型是 Java.util.Date比如现在是1月，定义了定时任务每月11号执行，然后这时设置了startTime为5月1号，那么这个定时任务第一次开始执行的时间是 5月11号 EndTime指定触发器的不再被触发的时间，它的值的类型是 Java.util.Date比如定义每月6号执行任务，设置EndTime设置为8月1号，那么最后一次执行的时间是7月6号 SimpleTrigger作用在一个指定的时间段内执行一次作业任务或是在指定的时间间隔内多次执行作业任务需要注意的点重复次数可以为0，正整数或是SimpleTrigger.REPEAT_INDEFINITY常量值重复执行间隔必须为0或长整数一旦被指定了endTime参数，那么它会覆盖重复次数参数的效果 CronTrigger基于日历的作业调度器而不是像SimpleTrigger那样精确执行间隔时间，比SimpleTrigger更常用Cron表达式用于配置CronTrigger实例是由7个子表达式组成的字符串，描述了时间表的详细信息格式 ：秒 分 时 日 月 周 年 quartz.properties首先读取项目resources目录下的配置文件，如果没有则读取自带的配置 调度器属性 org.quartz.scheduler.instanceName属性用来区分特定的调度器实例，可以按照功能用途来给调度器起名org.quartz.scheduler.instanceId和前者一样，也允许任何字符串，但这个值必须是在所有的调度器实例中是唯一的，尤其是在一个集群当中，作为集群的唯一key。假如你想Quartz帮你生成这个值的话，可以设置为AUTO 线程池threadCount 线程数量，至少为1threadPriority 设置线程的优先级 1-10，默认为5org.quartz.threadPool.class 可以自定义线程池，比如按照业务规模进行动态伸缩 作业存储设置插件配置 参考简单的Quartz Demo]]></content>
      <categories>
        <category>scheduler</category>
      </categories>
      <tags>
        <tag>quartz</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解GC日志]]></title>
    <url>%2F2019%2F08%2F22%2F%E7%90%86%E8%A7%A3GC%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[理解GC日志GC日志对于我们分析Java虚拟机内存问题很有帮助，GC日志格式有很多种，每一种格式都是由垃圾收集器来决定的，但是还是维持了一定的共性。下面就是一部分典型的GC日志（采用Parallel Scavenge和Parallel Old垃圾收集器）。 12345678910111213141516171819202122&#123;Heap before GC invocations=1 (full 0): PSYoungGen total 76288K, used 65536K [0x00000007f3300000, 0x00000007f8800000, 0x00000007f8800000) eden space 65536K, 100% used [0x00000007f3300000,0x00000007f7300000,0x00000007f7300000) from space 10752K, 0% used [0x00000007f7d80000,0x00000007f7d80000,0x00000007f8800000) to space 10752K, 0% used [0x00000007f7300000,0x00000007f7300000,0x00000007f7d80000) ParOldGen total 175104K, used 0K [0x00000007e8800000, 0x00000007f3300000, 0x00000007f3300000) object space 175104K, 0% used [0x00000007e8800000,0x00000007e8800000,0x00000007f3300000) Metaspace used 13988K, capacity 14304K, committed 14464K, reserved 1062912K class space used 1729K, capacity 1822K, committed 1920K, reserved 1048576K2020-05-30T18:35:21.111-0800: 0.791: [GC (Allocation Failure) Desired survivor size 11010048 bytes, new threshold 7 (max 15)[PSYoungGen: 65536K-&gt;6797K(76288K)] 65536K-&gt;6877K(251392K), 0.0044222 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] Heap after GC invocations=1 (full 0): PSYoungGen total 76288K, used 6797K [0x00000007f3300000, 0x00000007f8800000, 0x00000007f8800000) eden space 65536K, 0% used [0x00000007f3300000,0x00000007f3300000,0x00000007f7300000) from space 10752K, 63% used [0x00000007f7300000,0x00000007f79a3590,0x00000007f7d80000) to space 10752K, 0% used [0x00000007f7d80000,0x00000007f7d80000,0x00000007f8800000) ParOldGen total 175104K, used 80K [0x00000007e8800000, 0x00000007f3300000, 0x00000007f3300000) object space 175104K, 0% used [0x00000007e8800000,0x00000007e8814010,0x00000007f3300000) Metaspace used 13988K, capacity 14304K, committed 14464K, reserved 1062912K class space used 1729K, capacity 1822K, committed 1920K, reserved 1048576K&#125; 可以看到这个日志呈现了一次Young GC过程。0.791代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。GC日志开头的 GC代表了GC的类型，这里是Young GC，如果是Full GC，那么这里就是Full GC。接下来的[PSYoungGen]代表GC发生的区域，这里显示的内容跟采用不同的垃圾收集器有关，比如采用了ParNew收集器，那么这里显示的就是ParNew，我们这里采用的是Parallel Scavenge收集器，所以显示的PSYoungGen。后面的 65536K-&gt;6797K(76288K)含义是 GC前该内存区域使用容量 -&gt; GC后该内存区域使用容量（该内存区域总容量）。65536K-&gt;6877K(251392K)这个又代表了 GC前堆已使用容量 -&gt; GC后堆使用容量（堆的总容量）。再往后就是GC所花费的时间。比如说 [Times: user=0.01 sys=0.01, real=0.00 secs] ，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的CPU墙钟时间（Wall Clock Time）。CPU时间和墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以user或sys时间有时候会超过real时间。 PSYoung Gen total代表 新生代的容量，used 代表使用的容量，eden space 代表Eden空间容量，from space 代表From Survivor（S0）空间容量，to space代表To Survivor（S1）空间容量，后面的used代表该内存空间使用率。 ParOldGen total代表老年代的容量，used 代表使用的容量。 Metaspace 解释参考下图。 Metaspace由一个或多个虚拟空间组成，虚拟空间的分配单元是Chunk，其中Chunk使用列表进行维护。 当使用一个classLoader加载一个类时，过程如下： 123456781、当前classLoader是否有对应的Chunk且有足够的空间。2、查找空闲列表中的有没有空闲的Chunk。3、如果没有，就从当前虚拟空间中分配一个新的Chunk，这个时候会把对应的内存进行Commit，这个动作就是提交。4、如果当前虚拟空间不足，则预留(reserves)一个新的虚拟空间。reserved是jvm启动时根据参数和操作系统预留的内存大小。committed是指那些被commit的Chunk大小之和；capacity是指那些被实际分配的Chunk大小之和； 因为有GC的存在，有些Chunk的数据可能会被回收，那么这些Chunk属于committed的一部分，但不属于capacity。 另外，这些被分配的Chunk，基本很难被100%用完，存在碎片内存的情况，这些Chunk实际被使用的内存之和即used的大小； 参考 Metaspace Oracle官方文档 GC日志中，Metaspace的committed和reserved含义 JVM源码分析之Metaspace解密]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理]]></title>
    <url>%2F2019%2F08%2F13%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务事务指的是满足ACID特性的一组操作，可以通过commit提交一个事务，也可以使用Rollback进行回滚。MySQL事务主要用于处理操作量大，复杂度高的数据。 原子性（Atomicity）一个事务（transaction）中所有的操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。如果在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。 一致性（Consistency）在事务开始之前和事务结束以后，数据库的完整性没有被破坏，也就是说，数据库在事务执行前后都保持一致性状态，在一致性状态下，所有事务对一个数据的读取结果都是相同的。 隔离性（Isolation）一个事务所做的修改在最终提交以前，对其它事务是不可见的。 持久性（Durability）一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务的执行结果也不能丢失。使用重做日志来保证持久性。 在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。 并发一致性问题单线程下事务不会出现问题，因为是单个线程在操作数据库，事务操作成功则记录到磁盘里，失败则进行回滚，但是在并发环境下，有多个事务在操作数据库，事务的隔离性很难保证，因此会出现很多并发一致性问题。 丢失修改T1 和 T2 两个事务都对同一个数据进行修改，T1先修改，T2随后修改，T2的修改覆盖了T1的修改。 读脏数据T1修改一个数据，T2随后读取这个数据。如果T1撤销了这次修改，那么T2读取的数据是脏数据。 不可重复读指在一个事务中多次读取同一数据。在这个事务还没有结束时，另一个事务也访问该数据。T2读取一个数据，T1对该数据做了修改。如果T2再次读取这个数据，此时读取的结果和第一次读取的结果不同。 幻读T1读取某个范围内的数据，T2在这个范围内插入新的数据，T1再次读取这个范围内的数据，此时读取的结果和第一次读取的结果不同。 产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。 封锁封锁粒度MySQL中提供了两种封锁粒度：行级锁以及表级锁。 应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 封锁类型 读写锁 排它锁（Exclusive），简称为 X 锁，又称写锁 共享锁（Shared）， 简称为 S 锁，又称读锁 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其它事务不能对A加任何锁。一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其它事务能对A加S锁，但是不能加X锁。 锁的兼容关系： - X S X 否 否 S 否 是 意向锁 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 各种锁的兼容关系如下： - X IX S IS X 否 否 否 否 IX 否 是 否 是 S 否 否 是 是 IS 否 是 是 是 任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁； S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。 封锁协议在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则。例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议（Locking Protocol） 三级封锁协议 一级封锁协议（对应read uncommited）事务T要修改数据A时必须加X锁，直到T结束释放锁。在一级封锁协议当中，如果仅仅是读取数据而不对其进行修改，是不会加S锁的这个可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议（对应read commited）在一级封锁协议的基础上，要求读取数据 A 时必须加S锁，读取完马上释放S锁。由于读取完数据立即就释放S锁（并没有等待事务结束才释放锁），所以不能保证可重复读。可以解决脏读数据问题，因为如果一个事务对数A进行修改，根据一级封锁协议，必须对数据A加上X锁，加了X锁之后就不能加S锁了，也就是不会读到事务未提交的数据。 三级封锁协议（reapetable read）在二级的基础上，要求读取数据时必须加S锁，直到事务结束才能释放S锁。可以解决不可重复读的问题，因为读A时，其它事务不能对A加X锁，从而避免了在读的期间数据发生改变。 两段锁协议 加锁和解锁阶分为两个阶段进行。可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。 lock-x(A)…lock-s(B)…lock-s(C)…unlock(A)…unlock(C)…unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。 lock-x(A)…unlock(A)…lock-s(B)…unlock(B)…lock-s(C)…unlock(C) MySQL隐式与显式锁定MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。 InnoDB 也可以使用特定的语句进行显示锁定： SELECT … LOCK In SHARE MODE;SELECT … FOR UPDATE; 隔离级别读未提交（read uncommitted）事务对数据修改，即使没有提交，其它事务也能读取到。 读已提交(read committed)事务对数据修改，在没有提交之前，其它事务是不能读取的。也就是说一个事务所做的修改在未提交之前对其它事务都是不可见的。 可重复读 (repeatable read)保证在同一个事务中多次读取同样数据的结果是一样的。 可串行化 (serializable)强制事务串行执行。 隔离级别 脏读 不可重复读 幻影读 未提交读 √ √ √ 提交读 × √ √ 可重复读 × × √ 可串行化 × × × 多版本并发控制（MVCC）多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。 MySQL的大多数事务存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制。可以认为MVCC是行级锁的一个变种，但是它很多情况下避免了加锁，因此开销更低。 MVCC的实现是通过保存数据在某个时间点的快照来实现的，不同存储引擎的MVCC实现是不同的，典型的有 乐观并发控制 和 悲观并发控制。 MVCC 是如何工作的 InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间），当然这里的时间并不是实际的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录版本号进行比较。下面具体看一下在 REPEATABLE READ 隔离级别下，MVCC具体是如何操作的。 SELECT InnoDB会根据以下两个条件检查每行记录： InnoDB只查找早于当前事务版本号的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以保证事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 行的删除版本号要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。 INSERT InnoDB 为新插入的每一行保存当前系统版本号作为行版本号 DELETE InnoDB 为删除的每一行保存当前系统版本号作为行删除标识。 UPDATE InnoDB 为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识 保存这两个额外的系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好。但是不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。 快照读和当前读 快照读使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。 select * from table …; 当前读 读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。 12345select * from table where ? lock in share mode;select * from table where ? for update;insert;update;delete; Next-Key LocksNext-Key Locks是MySQL的InnoDB存储引擎的一种锁实现。 MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。 Record Locks锁定一个记录上的索引，而不是记录本身。 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。 Gap Locks锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。 SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE; Next-Key Locks它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间： 12345(-∞, 10](10, 11](11, 13](13, 20](20, +∞) 关系数据库设计理论todo 参考资料CS-Notes 『浅入浅出』MySQL 和 InnoDB nnodb中的事务隔离级别和锁的关系 MySQL-InnoDB-MVCC多版本并发控制]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim常用命令]]></title>
    <url>%2F2019%2F07%2F13%2Fvim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[vim常用命令vim三种模式 命令模式 12345678用户刚刚启动vi/vim，便进入了命令模式此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。以下是常用的几个命令：i 切换到输入模式，以输入字符。x 删除当前光标所在处的字符。: 切换到底线命令模式，以在最底一行输入命令。 输入模式 1在命令模式下按 i 就进入了输入模式 底线命令模式 12345678在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：q 退出程序w 保存文件 vim 常用命令 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) %d 清空文件内容 ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！ :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 其它特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <url>%2F2019%2F07%2F12%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用命令 在当前目录新建一个git代码仓库 1git init 新建一个目录，将其初始化为git代码库 1git init [project-name] 下载一个项目和它的整个代码历史 1git clone [url] 显示当前的git配置 1git config --list 编辑git配置文件，git的配置文件为.gitconfig，它可以在用户主目录下，也可以在项目目录下。 1git config -e [--global] 设置提交代码时的用户信息 123git config [--global] user.name &quot;[name]&quot;git config [--global] user.email &quot;[email address]&quot; 增加/删除/修改文件 123456789101112131415161718192021222324252627# 查看状态git status# 查看变更内容git diff# 添加指定文件到暂存区git add [file1] [file2]# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现多次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2]# 停止追踪指定文件，但文件会保留在工作区git rm --cached [file]# 改名文件，并将这次命名后的文件放入暂存区git mv [file-original] [file-endname] 代码提交 1234567891011121314151617# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区git commit -a# 提交时显示所有diff信息git commit -v# 如果代码没有任何新变化，则用来改写上一次commit的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit -amend [file1] [file2] 分支 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 查看所有本地分支git branch # 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 删除分支git branch -d [branch-name]git branch -D [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch]# 新建一个分支，并切换到该分支git checkout -b [branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 衍合指定分支到当前分支git rebase [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit] 标签 1234567891011121314151617181920212223# 列出所有本地标签git tag# 基于最新提交创建标签git tag &lt;tagname&gt;# 删除标签git tag -d &lt;tagname&gt;# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区域当前分支最新commit之间的差异git diff HEAD# 显示两次提交之前的差异git diff [first-branch] [second-branch]# 显示今天你写了多少行代码git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提价发生变化的文件git show --name-only [commit]# 系那是某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# 下载远程仓库的所有变动git fetch [remote]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] -all# 删除远程分支或标签git push &lt;remote&gt; :&lt;branch/tag-name&gt;# 上传所有标签git push --tags# 撤销工作目录中所有未提交文件的修改内容git reset --hard HEAD# 撤销指定的未提交文件的修改内容git checkout HEAD &lt;file&gt;# 撤销指定的提交git revert &lt;commit&gt; # 退回到之前1天的版本git log --before=&quot;1 days&quot;# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [flle]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 文件跟踪相关 1234567891011121314151617181920212223242526272829303132333435363738394041421. 列出跟踪了哪些文件git ls-files2. 取消跟踪文件夹下的所有文件（此项操作并不会删除取消跟踪的文件夹）git rm -r --cached test3. 取消跟踪某个或多个文件（此项操作并不会删除（工作区）取消跟踪的文件）git rm --cached a.txt git rm --cached a.txt b.txt4. 取消跟踪某个或多个文件（本地（工作区）取消跟踪的文件会被删除，该文件所在的文件夹也会被删除）git rm -f 1.txtgit rm -f 1.txt 2.txt5. git 不再追踪文件改动 git update-index --assume-unchanged filePath6. git 恢复追踪文件改动 git update-index —no-assume-unchanged filePath7. 可以把已经添加到暂存区的文件的修改撤销掉（unstage），重新放回工作区git reset HEAD &lt;file&gt; 8. 丢弃工作区修改的内容git checkout -- filename 9. 撤销暂存区所有已修改的文件的修改内容，重新放回工作区git reset --hard HEAD 原文链接https://www.toutiao.com/a6591290718067622407/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1&amp;timestamp=1534687079&amp;app=news_article&amp;utm_source=weixin&amp;iid=41405474498&amp;utm_medium=toutiao_ios&amp;group_id=6591290718067622407git 提升 clone 速度需要 ss 等科学上网客户端，这里的 1080 是 ss 等客户端默认监听的本地端口，如果你修改过，这里也需要修改git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080这里加了 --global 参数，所有用户和仓库都可以使用，也可以不加，不过每次使用的时候都要执行这两条命令。git show commitId 查看修改了哪些文件查看这个文件第159行到第180行之间的所有改动。git blame -L 159,180 resources/views/admin/customer/createCustomer.blade.php 14.其它123456# 移动未提交的内容到另一个新的分支1. 将当前更改保存到临时存储：$ git stash2. 基于此存储创建新分支，并切换到新分支：$ git stash branch &lt;new-branch&gt; stash@&#123;0&#125;]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+Tomcat搭建集群]]></title>
    <url>%2F2018%2F10%2F20%2FNginx-Tomcat%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[搭建环境 CentOS 7 Nginx 1.10.2 Tomcat 8.5.16 X 2 安装 Nginx 和 Tomcat安装过程在这里就不在赘述了，具体的可以参考网上教程。 分别修改2个 Tomcat 配置这里修改的主要是 Tomcat的 Web 监听端口，AJP端口，以及 关闭时候监听的端口，具体如下。tomcat 1 的配置文件如下：12345678&lt;Server port=&quot;8006&quot; shutdown=&quot;SHUTDOWN&quot;&gt; ... 省略一部分配置&lt;Connector port=&quot;7001&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;... 省略一部分配置 &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=&quot;8010&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; tomcat 2 的配置文件如下：12345678&lt;Server port=&quot;8007&quot; shutdown=&quot;SHUTDOWN&quot;&gt; ... 省略一部分配置&lt;Connector port=&quot;7002&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;... 省略一部分配置 &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;&lt;Connector port=&quot;8011&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt; 完成配置文件修改以后，我们就在服务器上部署了两台 Tomcat 实例。可以分别通过http://ip地址:7001/ 和 http://ip地址:7002 来访问测试。 修改 Nginx 的配置在 http 配置里添加以下部分1234upstream server_tomcat &#123; server 127.0.0.1:7001; server 127.0.0.1:7002;&#125; 在 server 里面添加或修改以下部分123456789101112 listen 7003; // nginx 监听的端口 server_name localhost; // 服务器名，可以填写服务器的ip，或者域名 #charset koi8-r; #access_log logs/host.access.log main; location / &#123; #root html; #index index.html index.htm;proxy_pass http://server_tomcat; &#125; 完成以上配置之后，我们就可以启动 nginx 了，来测试负载均衡是否正常。可以发现，每次刷新nginx代理都会转发不同的服务器，貌似两台两台服务器被访问的概率一样，实现了负载均衡。那么我们能不能设置每次访问两台服务器的概率不一样呢，答案是可以的，可以通过设置 weight 来达到访问概率不一样的效果，weight 越大，相应的服务器访问到的概率也就一样。1234upstream server_tomcat &#123; server 127.0.0.1:7001 weight=1; server 127.0.0.1:7002 weight=2;&#125; Nginx 服务器分配方式 默认 weight ip hash fair（第三方） url_hash （第三方）]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 配置主从分离]]></title>
    <url>%2F2018%2F09%2F09%2FMySQL-%E9%85%8D%E7%BD%AE%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[安装 MySQL（基于CentOS 7）首先我们要在两台服务器上安装好 MySQL数据库，安装过程在这里不在赘述。具体可参考CentOS7通过yum安装Mysql5.7+修改默认密码+远程登录。建议安装最近一年发布的版本。 配置主库修改 my.cnf 文件首先找到 MySQL 的配置文件 my.cnf（默认在 /etc/my.cnf 中）。增加以下配置123server-id=1 #数据库ID号log-bin=master-bin #启用二进制日志log-bin-index=master-bin.index #二进制日志名称 这是我的 my.cnf 配置。12345678910111213141516171819202122232425262728[mysqld]server-id=1 #数据库ID号log-bin=master-bin #启用二进制日志log-bin-index=master-bin.index #二进制日志名称#skip-grant-tables## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid 创建用户（用于从库读取主库的执行日志）登录到 MySQL 客户端之后，运行以下两行命令 121. GRANT REPLICATION SLAVE ON *.* TO &apos;用户名&apos;@&apos;192.168.0.2&apos; IDENTIFIED BY &apos;密码&apos;;2. flush privileges; 这里配置了只允许 从库（ip地址限定为从库） 以当前用户名访问主库。 查看主库的配置状态完成以上配置后，重启 MySQL1service mysqld restart 重启完成以后，登录到 MySQL 客户端查看主库配置状态，出现类似下面的结果则证明主库成功。1234567mysql&gt; show master status;+-------------------+----------+--------------+------------------+-------------------+| File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+-------------------+----------+--------------+------------------+-------------------+| master-bin.000002 | 16747 | | | |+-------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec) 然后记住 File 和 Position 的值，这个后面配置从库的时候需要用到。 从库配置修改从库的 my.cnf 文件在 my.cnf 中的 [mysqld] 下面加上以下内容 123server-id=2relay-log=slave-relay-binrelay-log-index=slave-relay-bin.index 关联主从库登录 MySQL 客户端之后，执行以下命令 123456change master to master_host=&apos;192.168.0.1&apos;, #Master 服务器Ipmaster_port=3306,master_user=&apos;用户名&apos;,master_password=&apos;密码&apos;, master_log_file=&apos;master-bin.000002&apos;, #Master日志文件名master_log_pos=16747; #Master日志同步开始位置，注意这里要和主库一样，不要写错，否则会造成配置失败。 接着，重启从库，然后登录到 MySQL 客户端，执行以下的命令 1start slave; 启动完成后，通过执行 show slave status \G; 命令查看 slave 的状态。 测试主从分离可以通过在 主库 创建一个数据库，接着查看 从库 是否同样的创建了一个同样的数据库。 参考资料 Mysql数据库之主从分离配置 CentOS7通过yum安装Mysql5.7+修改默认密码+远程登录]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java专项练习（牛客网）]]></title>
    <url>%2F2018%2F06%2F17%2FJava%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0%EF%BC%88%E7%89%9B%E5%AE%A2%E7%BD%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java专项练习（牛客网）第一题 What will happen when you attempt to compile and run the following code? 1234567891011121314151617public class Test &#123; static &#123; int x = 5; &#125; static int x, y; public static void main(String[] args) &#123; x--; myMethod(); System.out.println(x + y + ++x); &#125; public static void myMethod() &#123; y = x++ + ++x; &#125;&#125; 解析： 静态代码块中的 x 是局部变量，这里不会有什么影响，不用管 静态成员变量 x, y 的初始值都为 0 然后执行 x-- 之后 x 的值为 -1 ,调用 myMethod() 方法，执行 x++ 之后 x 的值变为 0，x++ 的值为 -1 ，然后接着执行 ++x ，这时 x 的值为 1 ，++x 的值也为 1，所以这时 y的值为 0，所以 x + y + ++x 的值为 1 + 0 + 2 = 3 静态成员常量必须被初始化，静态变量和普通成员变量不用初始化 第二题 以下程序的运行结果是？ 123456789101112public class TestThread &#123; public static void main() &#123; Runnable r = new Runnable() &#123; public void run() &#123; System.out.println("foo"); &#125; &#125;; Thread t = new Thread(r); t.run(); System.out.println("bar"); &#125;&#125; 解析：这里需要注意的是，新建了一个线程之后，并没有调用 start() 方法，所以这里并不会体现多线程，就只是和调用普通的类的 run() 方法是一样的，所以这时候的执行结果是 foobar，如果此时新建的线程调用了 start() 方法，那么这时候，该线程会被加入到等待队列当中，并不会马上开始执行该线程，等待CPU调用它，才会开始执行，所以这时候就可能有两个答案 foobar 或 barfoo。 第三题下面哪个行为被打断不会导致InterruptedException：Thread.joinThread.sleepObject.waitCyclicBarrier.awaitThread.suspend 解析：抛InterruptedException的代表方法有： java.lang.Object 类的 wait 方法 java.lang.Thread 类的 sleep 方法 java.lang.Thread 类的 join 方法 CyclicBarrier是一个屏障类，它的await方法可以简单的理解为：等待多个线程同时到达之后才能继续进行，在此之前它就是这些线程的屏障，线程不能继续进行，而对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 interruptedException）以反常的方式离开。因此它被中断也是可以抛出interruptedException的，如果还是不清楚，查看一下JavaAPI，对于这个类介绍的清清楚楚。 第四题List，Set，Queue 都继承于 Collection，SortedMap 继承于 MapCollection —–List —–LinkedList 非同步 —-ArrayList 非同步，实现了可变大小的元素数组 —-Vector 同步 ——Stack —–Set 不允许有相同的元素 Map —–HashTable 同步，实现一个key–value映射的哈希表 —–HashMap 非同步， —–WeakHashMap 改进的HashMap，实现了“弱引用”，如果一个key不被引用，则被GC回收 第五题 启动一个线程的方法是： thread.start() 结束一个线程的方式通常用interrupt()方法 让线程等待另一个线程的方法是 thread.wait() 将一个线程标记成daemon线程，意味着当主线程结束，并且没有其它正在运行的非daemon线程时，该daemon线程也会自动结束。 第六题GenericServlet类的实现接口中包括了ServletConfig接口，但是它自身的init(ServletConfig config)方法又需要外界给它传递一个实现ServletConfig的对象，就是说GenericServlet和ServletConfig的依赖关系既是继承关系，也是一种关联关系。 第七题在GoF设计模式中，结构型模式有： 1.适配器模式 Adapter 适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。 2.桥接模式 Bridge 桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。 3.组合模式 Composite 组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 4.装饰模式 Decorator装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。 5.外观模式 Facade 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。 6.享元模式 Flyweight 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。. 享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。 7.代理模式 Proxy为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。 第八题java.lang.OutOfMemoryError: PermGen space查了一下为”永久代”内存大小不足，“永久代”的解释应该为JVM中的方法区，主要用于存储类信息，常量，静态变量，即时编译器编译后代码等。本错误仅限于Hotspot虚拟机，本区进行垃圾回收很少，不够直接加大简单粗暴。 java.lang.OutOfMemoryError: Requested array size exceeds VM limit直接翻译报错信息：数组过长导致堆内存溢出，加大堆内存或者减少数组长度。 java.lang.OutOfMemoryError: Java heap space堆内存不足，直接增大堆内存。 java.lang.OutOfMemoryError: nativeGetNewTLA参考这里 第九题需要注意的是，null从技术上讲是一个直接量，而不是关键字Java关键字 第十题下列程序的输出结果是什么？ 12345678910public class Test1&#123; public static void main(String args[])&#123; String a=&quot;1234&quot;; String b=&quot;1234&quot;; String c = new String(&quot;1234&quot;); System.out.println(a==b); System.out.println(a==c); System.out.println(a.equals(c)); &#125;&#125; 解析：重新说下String的equals方法，不是说所有类的equals方法都只判断值。例如Object的equals方法的作用和==是相同的，都是判断引用。只不过String类重写了Object的equals方法而已，代码如下123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 先判断地址是否相等，如果相等直接返回true.否则先判断是否是String类型的，如果是在判断每个字符是否相等，如果都相等返回true，其余情况返回false 第十一题静态变量只能在类中定义，不能在类的方法中定义，静态变量属于类而不属于方法参考资料： Java修饰符大汇总 第十二题持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。而heapspace分为年轻带和年老带年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象年老代溢出原因有 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存，既A B D选项持久代溢出原因 动态加载了大量Java类而导致溢出参考资料：JVM 堆内存设置原理 第十三题 环境变量可在编译source code时指定 在编译程序时，所能指定的环境变量可以包括class path javac一次可同时编译数个Java源文件 javac.exe能指定编译结果要置于哪个目录（directory） 第十四题在《java虚拟机》一书中明确讲了，释放掉占据的内存空间是由 gc 完成，但是程序员 无法明确强制其运行 ，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。 Java 把内存划分成两种：一种是 栈内存 ，另一种是 堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。数组和对象 在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但 仍然占据内存空间不放 ，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。 第十五题1234567891011121314151617181920212223242526272829package Wangyi;class Base&#123; public void method() &#123; System.out.println(&quot;Base&quot;); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println(&quot;Son&quot;); &#125; public void methodB() &#123; System.out.println(&quot;SonB&quot;); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; 这个程序编译会不通过，因为向上转型，父类的引用无法访问子类独有的方法 第十六题抽象类中可以有抽象方法，一般是非抽象子类在实例化时调用 第十七题垃圾回收包含的内容不少，但顺着下面的顺序捋清知识也并不难。首先要搞清垃圾回收的范围（栈需要GC去回收吗？），然后就是回收的前提条件如何判断一个对象已经可以被回收（这里只重点学习根搜索算法就行了），之后便是建立在根搜索基础上的三种回收策略，最后便是JVM中对这三种策略的具体实现。 1.范围：要回收哪些区域？ Java方法栈、本地方法栈以及PC计数器随方法或线程的结束而自然被回收，所以这些区域不需要考虑回收问题。Java堆和方法区是GC回收的重点区域，因为一个接口的多个实现类需要的内存不一样，一个方法的多个分支需要的内存可能也不一样，而这两个区域又对立于栈可能随时都会有对象不再被引用，因此这部分内存的分配和回收都是动态的。 2.前提：如何判断对象已死？ （1）引用计数法 引用计数法就是通过一个计数器记录该对象被引用的次数，方法简单高效，但是解决不了循环引用的问题。比如对象A包含指向对象B的引用，对象B也包含指向对象A的引用，但没有引用指向A和B，这时当前回收如果采用的是引用计数法，那么对象A和B的被引用次数都为1，都不会被回收。 下面是循环引用的例子，在Hotspot JVM下可以被正常回收，可以证实JVM采用的不是简单的引用计数法。通过-XX:+PrintGCDetails输出GC日志。 12345678910111213141516171819202122232425package com.cdai.jvm.gc; public class ReferenceCount &#123; final static int MB = 1024 * 1024; byte[] size = new byte[2 * MB]; Object ref; public static void main(String[] args) &#123; ReferenceCount objA = new ReferenceCount(); ReferenceCount objB = new ReferenceCount(); objA.ref = objB; objB.ref = objA; objA = null; objB = null; System.gc(); System.gc(); &#125; &#125; [Full GC (System) [Tenured: 2048K-&gt;366K(10944K), 0.0046272 secs] 4604K-&gt;366K(15872K), [Perm : 154K-&gt;154K(12288K)], 0.0046751 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] （2）根搜索 通过选取一些根对象作为起始点，开始向下搜索，如果一个对象到根对象不可达时，则说明此对象已经没有被引用，是可以被回收的。可以作为根的对象有：栈中变量引用的对象，类静态属性引用的对象，常量引用的对象等。因为每个线程都有一个栈，所以我们需要选取多个根对象。 附：对象复活 在根搜索中得到的不可达对象并不是立即就被标记成可回收的，而是先进行一次标记放入F-Queue等待执行对象的finalize()方法，执行后GC将进行二次标记，复活的对象之后将不会被回收。因此，使对象复活的唯一办法就是重写finalize()方法，并使对象重新被引用。 123456789101112131415161718192021222324252627282930313233package com.cdai.jvm.gc; public class DeadToRebirth &#123; private static DeadToRebirth hook; @Override public void finalize() throws Throwable &#123; super.finalize(); DeadToRebirth.hook = this; &#125; public static void main(String[] args) throws Exception &#123; DeadToRebirth.hook = new DeadToRebirth(); DeadToRebirth.hook = null; System.gc(); Thread.sleep(500); if (DeadToRebirth.hook != null) System.out.println(&quot;Rebirth!&quot;); else System.out.println(&quot;Dead!&quot;); DeadToRebirth.hook = null; System.gc(); Thread.sleep(500); if (DeadToRebirth.hook != null) System.out.println(&quot;Rebirth!&quot;); else System.out.println(&quot;Dead!&quot;); &#125; &#125; 要注意的两点是：第一，finalize()方法只会被执行一次，所以对象只有一次复活的机会。第二，执行GC后，要停顿半秒等待优先级很低的finalize()执行完毕。 3.策略：垃圾回收的算法 （1）标记-清除 没错，这里的标记指的就是之前我们介绍过的两次标记过程。标记完成后就可以对标记为垃圾的对象进行回收了。怎么样，简单吧。但是这种策略的缺点很明显，回收后内存碎片很多，如果之后程序运行时申请大内存，可能会又导致一次GC。虽然缺点明显，这种策略却是后两种策略的基础。正因为它的缺点，所以促成了后两种策略的产生。 （2）标记-复制将内存分为两块，标记完成开始回收时，将一块内存中保留的对象全部复制到另一块空闲内存中。实现起来也很简单，当大部分对象都被回收时这种策略也很高效。但这种策略也有缺点，可用内存变为一半了！ 怎样解决呢？聪明的程序员们总是办法多过问题的。可以将堆不按1:1的比例分离，而是按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了新生代。 从下图可以看到这三块区域如何配合完成GC的，具体的对象空间分配以及晋升请参加后面第6条补充。 为什么不是全部呢？如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是老年代的用处。当不够用时，这些对象将直接通过分配担保机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。 （3）标记-整理根据老年代的特点，采用回收掉垃圾对象后对内存进行整理的策略再合适不过，将所有存活下来的对象都向一端移动。 4.实现：虚拟机中的收集器 （1）新生代上的GC实现Serial：单线程的收集器，只使用一个线程进行收集，并且收集时会暂停其他所有工作线程（Stop the world）。它是Client模式下的默认新生代收集器。ParNew：Serial收集器的多线程版本。在单CPU甚至两个CPU的环境下，由于线程交互的开销，无法保证性能超越Serial收集器。Parallel Scavenge：也是多线程收集器，与ParNew的区别是，它是吞吐量优先收集器。吞吐量=运行用户代码时间/(运行用户代码+垃圾收集时间)。另一点区别是配置-XX:+UseAdaptiveSizePolicy后，虚拟机会自动调整Eden/Survivor等参数来提供用户所需的吞吐量。我们需要配置的就是内存大小-Xmx和吞吐量GCTimeRatio。 （2）老年代上的GC实现Serial Old：Serial收集器的老年代版本。Parallel Old：Parallel Scavenge的老年代版本。此前，如果新生代采用PS GC的话，老年代只有Serial Old能与之配合。现在有了Parallel Old与之配合，可以在注重吞吐量及CPU资源敏感的场合使用了。CMS：采用的是标记-清除而非标记-整理，是一款并发低停顿的收集器。但是由于采用标记-清除，内存碎片问题不可避免。可以使用-XX:CMSFullGCsBeforeCompaction设置执行几次CMS回收后，跟着来一次内存碎片整理。 5.触发：何时开始GC？ Minor GC（新生代回收）的触发条件比较简单，Eden空间不足就开始进行Minor GC回收新生代。而Full GC（老年代回收，一般伴随一次Minor GC）则有几种触发条件：（1）老年代空间不足（2）PermSpace空间不足（3）统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间 这里注意一点：PermSpace并不等同于方法区，只不过是Hotspot JVM用PermSpace来实现方法区而已，有些虚拟机没有PermSpace而用其他机制来实现方法区。 6.补充：对象的空间分配和晋升 （1）对象优先在Eden上分配 （2）大对象直接进入老年代 虚拟机提供了-XX:PretenureSizeThreshold参数，大于这个参数值的对象将直接分配到老年代中。因为新生代采用的是标记-复制策略，在Eden中分配大对象将会导致Eden区和两个Survivor区之间大量的内存拷贝。 （3）长期存活的对象将进入老年代 对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度 （默认为15岁）时，就会晋升到老年代中。 第十八题 功能性注释嵌在源程序中，用于说明程序段或语句的功能以及数据的状态。 可使用空行或缩进，以便很容易区分注释和程序。 修改程序也应修改注释。 第十九题 线程运行速度与线程的优先级无关。 第二十题超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。服务器。端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）路径。（以“/”字符区别路径中的每一个目录名称）查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）典型的统一资源定位符看上去是这样的： (带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment 第二十一题java中的字符串存储在 字符串常量区，不会改变，发生改变 是会 新创建一个对象StringBuffer是 线程安全的StringBuilderStringBuilder跟StringBuffer功能相同，区别是StringBuilder 不是 线程安全的StringBuilder和StringBuffer底层都是以 字符数组 存放的，可以 修改 内容 第二十二题一般关系数据模型和对象数据模型之间有以下对应关系：表对应类 ，记录对应对象 ，表的字段对应类的属性 第二十三题sleep和wait的区别有： 这两个方法来自不同的类分别是Thread和Object 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 1234synchronized(x)&#123; x.notify() //或者wait()&#125; sleep必须捕获异常，而 和 notifyAll``` 不需要捕获异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556### 第二十四题编译不会编译注释中的内容。javac编译后的字节码文件中也不会出现自己手打的注释。 ### 第二十五题Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素：1) 事件源（Event Source）：即事件发生的场所，就是指各个组件，如按钮等，点击按钮其实就是组件上发生的一个事件；2) 事件（Event）：事件封装了组件上发生的事情，比如按钮单击、按钮松开等等；3) 事件监听器（Event Listener）：负责监听事件源上发生的特定类型的事件，当事件到来时还必须负责处理相应的事件；### 第二十六题对象的初始化方式： 1. new时初始化； 2. 静态工厂 newInstance； 3. 反射Class.forName()； 4. clone方式； 5. 反序列化； ### 第二十七题1. 类方法是指类中被 `static` 修饰的方法，`无` this指针。2. 类方法是可以调用其他类的static方法的。3. 可以在类方法中 `生成实例对象` 再调用实例方法。### 第二十八题在Java中，函数代码小，频繁调用的情况下适合采用内联函数在说内联函数之前，先说说函数的调用过程。 调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到 转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保 存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体 代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。 那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。内联函数就是在程序编译时，编译器将程序中出现 的内联函数的调用表达式用内联函数的函数体来直接进行替换。显然，这样就不会产生转去转回的问题，但是由于在编译 时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时 那么大，可见它是以目标代码的增加为代价来换取时间的节省。 在大学里学习写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用 到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的 处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等） 写过C++代码的应该都知道，在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被 编译器视为内联函数。 那么，在java中的内联函数长什么模样呢？在java中使用final关键字来指示一个函数为内联函数，例如：```javapublic final void method1() &#123; //TODO something &#125; 这个指示并不是必需的。final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。 第二十九题double m = 3; // 正确double m = 3.0; // 正确Double m = 3; // 错误Double m = 3.0; // 正确int m = 0.0 // 错误float m = 3; // 正确float m = 3.0; // 错误，需要强制类型转换 第三十题算法包括0个或多个输入，1个或多个输出，中间有穷个处理过程。存储结构不属于算法结构 下面是维基百科对算法的定义输入：一个算法必须有零个或以上输入量。输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。 第三十一题下列程序输出结果是：1234567891011121314151617public class Example &#123; String str = new String(&quot;good&quot;); char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + &quot; and &quot;); System.out.print(ex.ch); &#125; public static void change(String str, char ch[]) &#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; &#125;&#125; 最后的输出结果是： good and gbc 分析：这里需要注意的是，在java中只有按值传递，不管是基本类型还是对象，并没有按引用传递（详情见119页Java核心技术卷I），change函数被调用时，第一个形参str接收了类的成员变量str的值（虽然名称都是str，但是却是两个独立的String类型的引用变量），注意这两个str自身都是变量且都指向了堆内存中的String对象”good”，当我们在change函数内部将str指向了另一个String对象”test ok”后，类的成员变量str仍然保持指向”good”，所以最终打印出来就是”good”；对于第二个形参ch，它也是接收了类的成员变量ch的值拷贝，这一点和str没有差别，即两个ch都指向了字符数组{ ‘a’, ‘b’, ‘c’ }的首地址，但是ch[0]表示的是字符数组中’a’的地址，修改了它也就修改了字符数组的第一个元素，这个改变在change函数返回之后也会存在。所以本题中两个形参传参的本质区别在于，修改str只是将形参指向了新的对象，对外部的实参没有任何影响，而修改ch[0]是实实在在的修改了字符数组的首元素。扩展： 可以试验一下，在Example中再定义一个字符数组char[] ch2={‘d’};然后在change函数中把ch[0] = ‘g’;这句改成ch=ch2;，那么就会和str传参一样的，change函数返回后不会对类的成员ch有任何影响。 本题和“String类是一个final类，不能被继承”以及“String底层的字符数组被声明为private final char value[];所以其值不能被修改”这些String的特性无关。 我们平时交换数组中的两个元素时，一般定义swap方法为 void swap(int[] a, int i, int j)，想想看为什么能达到目的？如果不使用数组，能实现交换吗？数组中存放的不是基本类型变量而是引用类型变量呢？ 第三十二题A、Semaphore：类，控制某个资源可被同时访问的个数;B、ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；C、 Future：接口，表示异步计算的结果；D、 CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。 第三十三题在单行文本输入区(Textfield)构件上可能发生的事件包括 FocusEvent 焦点事件，所对应的事件监听器是 FocusListener ； ActionEvent 动作事件，所对应的事件监听器是 ActionListener ； MouseEvent 鼠标事件，所对应的事件监听器是 MouseMotionListener 。 第三十四题HttpServlet容器响应Web客户请求流程如下： Web客户向Servlet容器发出Http请求； Servlet容器解析Web客户的Http请求； Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息； Servlet容器创建一个HttpResponse对象； Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象； HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息； HttpServlet调用HttpResponse的有关方法，生成响应数据； Servlet容器把HttpServlet的响应结果传给Web客户。 第三十五题 ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized; HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Cllectio Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList； SimpleDateFormat是线程不安全的 第三十六题事务属性的种类：传播行为、隔离级别、只读和事务超时 传播行为定义了被调用方法的事务边界。 传播行为 意义 PROPERGATION_MANDATORY 表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常 PROPAGATION_NESTED 表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED看起来没什么俩样 PROPAGATION_NEVER 表示方法不能运行在一个事务中，否则抛出异常 PROPAGATION_NOT_SUPPORTED 表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起 PROPAGATION_REQUIRED 表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务 PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起 PROPAGATION_SUPPORTS 表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中 隔离级别在操作数据时可能带来 3 个副作用，分别是脏读、不可重复读、幻读。为了避免这 3 中副作用的发生，在标准的 SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，如下： 隔离级别 意义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读 ISOLATION_READ_COMMITTED 允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读 ISOLATION_REPEATABLE_READ 一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读 ISOLATION_SERIALIZABLE 这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。 只读如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。 因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。 如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。 事务超时如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。 第三十六题ArrayList的构造函数总共有三个： ArrayList()构造一个初始容量为 10 的空列表。 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有 指定初始容量 的空列表。调用的是第三个构造函数，直接初始化为大小为20的list，没有扩容，所以选择A 参考资料： 常用集合的默认初始容量和扩容的原因 ArrayList动态扩容机制 第三十七题&gt;&gt; 为带符号右移，右移后左边的空位被填充为 符号位&gt;&gt;&gt; 为不带符号右移，右移后左边的空位被填充为 0没有 &lt;&lt;&lt; 因为 &lt;&lt; 后右边 总是补0 第三十八题12345678910111213package NowCoder;class Test &#123; public static void hello() &#123; System.out.println("hello"); &#125;&#125;public class MyApplication &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Test test = null; test.hello(); &#125;&#125; 该代码能正常运行解析：类方法（就是静态方法）不依附于对象，所以当然可以正常运行 引用不同于指针，引用中既包含指向对象的指针、又包含指向类的指针，test中指向对象的指针确实为空，但指向Test的指针可不为空 第三十九题Web容器在启动时为每个Web应用创建一个ServletContext对象，ServletConfig对象中维护了ServletContext的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 多个Servlet通过ServletContext对象实现数据共享。 在InitServlet的Service方法中利用ServletContext对象存入需要共享的数据ServletContext context = this.getServletContext();context.setAttribute(“name”, “haha”); 在其它的Servlet中利用ServletContext对象获取共享的数据ServletContext context = this.getServletContext();String name = context.getAttribute(“name”); 获取WEB应用的初始化参数。 在DemoServlet的doPost方法中测试获取初始化参数的步骤如下: ServletContext context = this.getServletContext();String url = context.getInitParameter(“url”); 第四十题jvm虚拟机的功能： 通过 ClassLoader 寻找和装载 class 文件 解释字节码成为指令并执行，提供 class 文件的运行环境 进行运行期间垃圾回收 提供与硬件交互的平台 第四十一题在Java中，对于不再使用的内存资源，如调用完成的方法，不是 由 垃圾回收器 自动将其释放，而是方法调用时，会创建 栈帧 在栈中，调用完是 程序自动出栈释放 第四十二题Spring并没有提供一个AOP方式的日志系统，而是我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。Spring是一系列轻量级Java EE框架的集合，比如： spring context ,spring aop ,springMVC ,spring ORm ,spring web ,spring dao,core context Spring中包含一个“依赖注入”模式的实现使用Spring可以实现声明式事务 第四十三题HashTable和HashMap区别 继承不同。 12public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 第四十四题在Java中，关于接口实现类的方法这里还有几点需要注意： 接口中的方法如果抛出了异常，那么实现类中的方法跑出的异常必须 &lt;= 接口中的方法抛出的异常 接口的中方法的返回值类型如果是Person，它的一个子类是Student，父类是Animal，那么实现类中的方法的返回值类型必须是 Student 或 Person，不能是Animal 实现类中的方法名、参数类型个数顺序都必须和接口中的方法相同 接口中的方法的默认权限是 public ，那么实现类重写后的方法的权限 只能是public 第四十五题String a = “llo”;String str1 = “hello”;String str2 = “he” + new String(“llo”);String str3 = “he” + “llo”;String str4 = “he” + a;System.out.println(str1 == str2); // falseSystem.out.println(str1 == str3); // trueSystem.out.println(str1 == str4); // false 解析：String str1= “hello”, String str2=”he”+”llo”;之所以str1\=\=str2返回true是因为两者都是在字符串常量池中（由于初始化就会在此区域分布内存）而常量池中的有个与栈区类似的特性，就是当str2指向的常量在常量区已存在时，他不会创建新的内存空间来存此常量，而是指向已有常量的内存（应该是以此节约空间），此时str1与str2这两个引用变量的值都是存”hello”的内存空间地址，但是String str3= “he”+a;String a=”llo”;时str1\=\=str3返回的为false，是因为：str1指向的hello在编译期一如既往的还是分配在常量区内，a指向的llo也在常量区，虽然str3也是初始化但是编译器无法判断a这货到底是什么个情况，进而不会将str3的等号右侧声明在常量区内，而是在通过构造时在堆区中的非常量池外的内存中声明，至此str3与str1不止是分配内存的时期不同（一个在编译期，一个在运行期）而且在内存空间的区域也不同，上面最高票答案只区分了时间没区分空间。 第四十六题java语言的下面几种数组复制方法中，哪个效率最高？ 复制的效率 System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for 循环，这个有兴趣自己测试一下就知道了。这里面在System类源码中给出了arraycopy的方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.arraycopy的，多了一个步骤，肯定就不是最快的 第四十七题1234567891011121314package algorithms.com.guan.javajicu; public class Inc &#123; public static void main(String[] args) &#123; Inc inc = new Inc(); int i = 0; inc.fermin(i); // 这句话其实并没有用，java中参数传递都是按值传递 i = i++; // 这里需要注意的是 i = i++ , i = ++i 和 i = i + 1 并不相同，前者i的值是 0 ，中间i的值是 1， 后者i的值是 1 System.out.println(i); &#125; void fermin(int i)&#123; i++; &#125; &#125; 最终的运行结果是： 0 第四十八题在java中线程是有分优先等级的所以优先级不能相同Thread实现了Runnable接口是一个类不是接口实现多线程的三种方式，一种是继承Thread类使用此方式就不能继承其他的类了。还有两种是实现Runnable接口或者实现Callable接口 第四十九题Servlet生命周期 Servlet的生命周期一般可以用三个方法来表示： init()：仅执行一次，负责在装载Servlet时初始化Servlet对象 service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。 destroy()：在停止并且卸载Servlet时执行，负责释放资源 初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。 第五十题 从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器. 浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 从效率来说 forward:高. redirect:低. 第五十一题 有两个类 A 和 B，B 继承 A，且 A 和 B 中均有静态代码块和非静态代码块，那么获取 B 的一个实例时，相应的执行顺序如下。先执行 A 类中的静态代码块，再执行 B 类中的代码块接着执行 A 类中的非静态代码块和构造函数最后执行 B 类中的非静态代码块和构造和函数。 第五十二题 java 中访问权限 作用域 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 第五十三题中间件运行于操作系统之上，应用软件之下，而不是操作系统内核之中。中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理） 第五十四题1234567891011121314151617181920A：设置HTTP头标 response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); //三秒刷新页面一次B：设置cookieCookie c1 = new Cookie(&quot;username&quot;,&quot;only&quot;);response.addCookie(c1);C（错误）：读取路径信息,request读取路径信息从request获取各种路径总结request.getRealPath(&quot;url&quot;); // 虚拟目录映射为实际目录request.getRealPath(&quot;./&quot;); // 网页所在的目录request.getRealPath(&quot;../&quot;); // 网页所在目录的上一层目录request.getContextPath(); // 应用的web目录的名称D：输出返回数据HttpServleteResponse.getOutputStream().write(); 第五十五题关于PreparedStatement 和 Statement 描述 PreparedStatement 比 Statement 执行效率更高 PreparedStatement 会预编译 SQL 语句 Statement 每次都会解析/编译 SQL 语句确立并优化数据获取路径 第五十六题关于运算符优先级 单目&gt;运算&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 第五十七题当程序执行到try{}语句中的return方法时，它会干这么一件事，将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的程序。并不是说return后面的语句不执行，只是要等到finally{}中的语句（不存在return语句）执行完后，再返回。如果finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。 第五十八题一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况多线程下计数器必须使用锁保护 第五十九题int x = 1, float y = 2, 则表达式 x / y 的值为：0.5 解析： 当多个数字进行运算的时候，最终结果以 最高精度 的为准 参考：①float x = 1；与float x = 1.0f，这两种对于float类型的变量来说定义的方式都是正确的，也是比较常见的笔试题里面考察类型转换的例子，当第一种情况时，是将低精度int向上转型到float，是由于java的特性导致而不需要进行强制转换，而第二种情况则是比较正式的对于float变量的定义，由于这种类型本身在工作项目中并不常见，常用的带小数的数字我们一般都直接使用double类型，而double类型直接定义是没有问题的：double x = 1.0。而由于float的精度没有double类型高，因此必须对其进行显示的格式书写，如果没有这个f，就默认是double类型了。当然double x = 1.0d也是正确的命名，不信你可以尝试，虽然这是一个令人窒息的操作。②当多个精度的数字同时进行运算时，最终结果以最高精度为准。在多数情况下，整数和小数的各级混合运算中，一般结果都是double类型的。但就本题而言，结果是float类型的，因为x，y两个数字精度最高的就是float，所以最终结果是0.5，并且这个0.5是float类型的。为什么说不是double类型呢，当然如果你这样处理：double m = x/y，当然m是double类型的，也不会报错，而如果你写成int m = x/y，编译器报错提示的时候就会让你转换成float或者进行强制转换成int，他是不会提示你转换成double的，尽管这么写并没有报错，原因就是① 第六十题 在 HashMap 中，前后插入两个相同的键值，后一个键值对应的value会覆盖前一个键值的value 第六十一题123456789101112131415161718192021222324252627282930313233343536public class Test &#123; int i = 1; static int b = 3; private String a = "333"; private static String c = "ffafd"; class Inner1 &#123; void test() &#123; System.out.println(i); System.out.println(b); System.out.println(a); System.out.println(c); &#125; /** * 非静态内部类 * 可以 访问外围类的非静态属性，包括私有属性 * 可以 访问外围类的静态属性，包括私有静态属性 */ &#125; static class Inner1 &#123; void test() &#123; System.out.println(i); // 会报错 System.out.println(b); System.out.println(a); // 会报错 System.out.println(c); &#125; /** * 静态内部类 * 不可以 访问外围类的非静态属性，包括私有属性 * 可以 访问外围类的静态属性，包括私有静态属性 */ &#125; &#125; 第六十二题抽象方法 不能 有方法体，同时也 不能 有大括号，以分号结尾。 第六十三题Java 中创建数组的几种写法 1234float f[][] = new float[6][6];float []f[] = new float[6][6];float [][]f = new float[6][6];float [][]f = new float[6][]; 第六十四题异常相关 throws 用于在方法上 声明 要抛出的异常，不是用来抛出异常的 throw 用于抛出异常 第六十五题内部类（也叫成员内部类）有四种访问权限 第六十六题Object 对象中的方法 1．clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 2．getClass方法 final方法，获得运行时类型。 3．toString方法 该方法用得比较多，一般子类都有覆盖。 4．finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5．equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6．hashCode方法 该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 7．wait方法 wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8．notify方法 该方法唤醒在该对象上等待的某个线程。 9．notifyAll方法 该方法唤醒在该对象上等待的所有线程。 第六十七题以下表达式都是正确的 12long i = 0xfffL;double i = 0.9339d;(一般后面不用加 d, 默认就是 d) 第六十八题 hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全 Arrays.asList() 将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。 加载驱动方法 1231.Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;);2. DriverManager.registerDriver(new com.mysql.jdbc.Driver());3.System.setProperty(&quot;jdbc.drivers&quot;, &quot;com.mysql.jdbc.Driver&quot;); Jsp只会在客户端第一次发请求的时候被编译，之后的请求不会再编译，同时tomcat能自动检测jsp变更与否，变更则再进行编译。第一次编译并初始化时调用： init() ；销毁调用： destroy() 。在整个jsp生命周期中均只调用一次。service()方法是接收请求，返回响应的方法。每次请求都执行一次，该方法被HttpServlet封装为doGet和doPost方法创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet(2)创建：通过调用servlet构造函数创建一个servlet对象(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源 Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期在禁用Cookie时可以使用URL重写技术跟踪会话 第六十九题就是源Ip地址，目标IP地址，源端口号和目标端口号的组合服务器端：ServerSocket提供的实例1ServerSocket server= new ServerSocket(端口号) 客户端：Socket提供的实例1Socket soc=new Socket(ip地址，端口号) 第七十题ResultSet跟普通的数组不同，索引从1开始而不是从0开始 第七十一题12345678910public interface Test &#123; public void fun(); abstract void fun2(); static void fun3() &#123; System.out.println(&quot;java8 新特性&quot;); &#125; default void fun4() &#123; System.out.println(&quot;java8 新特性+1&quot;); &#125;&#125; 第七十二题 静态内部类才可以声明静态方法 静态方法不可以使用非静态变量 抽象方法不可以有函数体 第七十三题Java字节码是Java源文件编译产生的中间文件，java虚拟机是可运行java字节码的假想计算机，java的跨平台性也是相对与其他编程语言而言的，先介绍一下c语言的编译过程吧先是C语言源程序 也就是c的文件经过C编译程序编译后，生成windows可执行文件exe文件，然后在windows中执行。再介绍java的编译过程先是java源程序扩展名为java的文件，由java编译程序将java字节码文件，就是class文件然后在java虚拟机中执行。机器码是由CPU来执行的。Java编译后是字节码， 电脑只能运行机器码。Java在运行的时候把字节码变成机器码。C/C++在编译的时候直接编译成机器码。 第七十四题WSDL 可描述网络服务（Web Services）WSDL 指网络服务描述语言 (Web Services Description Language)。WSDL 是一种使用 XML 编写的文档。这种文档可描述某个 Web service。它可规定服务的位置，以及此服务提供的操作（或方法） 第七十五题 intValue()是把Integer对象类型变成int的基础数据类型 parseInt()是把String 变成int的基础数据类型 Valueof()是把String 转化成Integer对象类型 第七十六题堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。 年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收永久代：存储的是final常量，static变量，常量池。str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回 第七十七题A. Vector相当于一个线程安全的ListB. HashMap是非线程安全的，其对应的线程安全类是HashTableC. Arraylist是非线程安全的，其对应的线程安全类是VectorD. StringBuffer是线程安全的，相当于一个线程安全的StringBuilderE. Properties实现了Map接口，是线程安全的 第七十八题 构造函数是不能继承的，只是用来在子类调用,（如果父类没有无参构造函数，创建子类时，必须在子类构造函数代码体的第一行显式调用父类的有参数构造函数，否则不能编译）; 如果父类没有有参构造函数,那么在创建子类时可以不显式调用父类构造函数,系统会默认调用父类的无参构造函数super(); 如果父类没有无参构造函数,那系统就调不了默认的无参构造函数了,所以不显示调用编译也就无法通过了 补充说明： 在java中,创建有参构造函数后,系统就不在有默认的无参构造函数 如果父类中没有任何构造函数,系统会默认有一个无参的构造函数 第七十九题A. Thread可以被继承，用于创建新的线程B. Number类可以被继承，Integer，Float，Double等都继承自Number类C. Double类的声明为1public final class Doubleextends Numberimplements Comparable final生明的类不能被继承D. Math类的声明为1public final class Mathextends Object 不能被继承E. ClassLoader可以被继承，用户可以自定义类加载器 第八十题枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：123456789101112131415161718192021222324252627private AccountType() &#123; System.out.println(&quot;It is a account type&quot;); &#125;会变成：private AccountType(String s, int i) &#123; super(s,i); System.out.println(“It is a account type”); &#125;而在这个类中，会添加若干字段来代表具体的枚举类型：public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT;而且还会添加一段static代码段：static&#123; SAVING = new AccountType(&quot;SAVING&quot;, 0); CURRENT = new AccountType(&quot;CURRENT&quot;, 0); $VALUES = new AccountType[]&#123; SAVING, FIXED, CURRENT &#125; &#125;以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍 第八十一题for 循环的执行顺序 12345678910111213public class Print&#123; static boolean out(char c)&#123; System.out.println(c); return true; &#125; public static void main(String[] argv)&#123; int i = 0; for(out('A');out('B') &amp;&amp; (i&lt;2);out('C'))&#123; i++; out('D'); &#125; &#125;&#125; 最后的运行结果是：ABDCBDCB12345678910for循环执行开始首先执行out(&apos;A&apos;) 输出A；然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2)此时输出B，i=0，判断条件为真，执行for循环的循环体；执行i++，out(&apos;D&apos;)，输出D i=1；执行out(&apos;C&apos;),输出C 然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2) 此时输出B，i=1 判断条件为真 ，执行for循环的循环体；执行i++，out(&apos;D&apos;)，输出D i=2；执行out(&apos;C&apos;),输出C 然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2) 此时输出B，i=2，不满足i&lt;2 判断条件为假 ，跳出循环；所以结果为ABDCBDCB 第八十二题010 八进制 80x8 十六进制 8 第八十三题12345678910public class StringDemo&#123; private static final String MESSAGE="taobao"; public static void main(String [] args) &#123; String a ="tao"+"bao"; String b="tao"; String c="bao"; System.out.println(a==MESSAGE); System.out.println((b+c)==MESSAGE); &#125;&#125; 运行结果： 这题是在考编译器的优化，hotspot中 编译时”tao”+”bao”将直接变成”taobao”，b+c则不会优化，因为不知道在之前的步骤中bc会不会发生改变，而针对b+c则是用语法糖，新建一个StringBuilder来处理 第八十四题父类没有无参的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数 第八十五题12345String x=&quot;fmn&quot;;x.toUpperCase();String y=x.replace(&apos;f&apos;,&apos;F&apos;);y=y+&quot;wxy&quot;;System.out.println(y); 解析：String x=”fmn”; “fmn”是在常量池里的不可变对象。x.toUpperCase(); 在堆中new一个”FMN”对象，但无任何引用指向它。String y=x.replace(‘f’,’F’); 在堆中 new一个”Fmn”对象，y指向它。y=y+”wxy”; 在堆中 重新new一个”Fmnwxy”对象， 修改y指向，现在y指向它。 第八十六题数组不是基本类型，在java中，数据类型就分为基本数据类型(即原生类)和引用数据类型，所以数组不是原生类。 第八十七题序列化相关 一、序列化使用场景对象的序列化：目的：将一个具体的对象进行持久化，写入到硬盘上。（注意：静态数据不能被序列化，因为静态数据不在堆内存中，而是在静态方法区中）Serializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。 二、非序列化使用场景如何将非静态的数据不进行序列化？用transient 关键字修饰此变量即可。使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等） java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 第八十八题标识符是以字母开头的字母数字序列：数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；字母、数字等字符的任意组合，不能包含+、- *等字符；不能使用关键字；大小写敏感 第八十九题动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=”included.jsp” flush=”true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。 静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=”included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。 以下是对 include 两种用法的区别 ， 主要有两个方面的不同 ;1234567一 : 执行时间上 :&lt;%@ include file=&quot;relativeURI&quot;%&gt; 是在翻译阶段执行&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 在请求处理阶段执行 .二 : 引入内容的不同 :&lt;%@ include file=&quot;relativeURI&quot;%&gt;引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 .&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 引入执行页面或 servlet 所生成的应答文本 . 第九十题1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String args[]) &#123; String str1 = new String(&quot;hello&quot;); String str2 = new String(&quot;hello&quot;); String str3 = &quot;hello&quot;; String str4 = &quot;hello&quot;; String str5 = &quot;he&quot;+&quot;llo&quot;; String str6 = &quot;he&quot;; String str7 = &quot;llo&quot;; System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str3==str4); System.out.println(str3==&quot;hello&quot;); System.out.println(str4==(str6+str7)); &#125;&#125;上面代码的输出结果是：falsefalsetruetruefalse1String str1 = new String(&quot;hello&quot;);这种方式创建的字符串，和正常创建对象一样，保存在堆区。1String str3 = &quot;hello&quot;;这种方式创建的字符串，保存在字符串常量区。 第九十一题InputStreamReader(InputStream in, Charset cs)创建使用给定字符集的 InputStreamReader。 第九十二题Servlet 与 CGI 的比较 和CGI程序一样，Servlet可以响应用户的指令(提交一个FORM等等)，也可以象CGI程序一样，收集用户表单的信息并给予动态反馈(简单的注册信息录入和检查错误)。然而，Servlet的机制并不仅仅是这样简单的与用户表单进行交互。传统技术中，动态的网页建立和显示都是通过CGI来实现的，但是，有了Servlet,您可以大胆的放弃所有CGI(perl?php?甚至asp!)，利用Servlet代替CGI,进行程序编写。 当用户浏览器发出一个Http/CGI的请求，或者说 调用一个CGI程序的时候，服务器端就要新启用一个进程 (而且是每次都要调用)，调用CGI程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。而Servlet充分发挥了服务器端的资源并高效的利用。每次调用Servlet时并不是新启用一个进程 ，而是在一个Web服务器的进程敏感词享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。 传统的CGI程序，不具备平台无关性特征，系统环境发生变化，CGI程序就要瘫痪，而Servlet具备Java的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。 传统技术中，一般大都为二层的系统架构，即Web服务器+数据库服务器，导致网站访问量大的时候，无法克服CGI程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而我们的Servlet有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。 第九十四题 标准ASCII只使用7个bit，扩展的ASCII使用8个bit。 ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。不同 ANSI 编码之间互不兼容。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。 ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符，即ASCII码 ASCII码包含一些特殊空字符 第九十五题 在Java中，先继承再实现 java 的字符类型采用的是 Unicode 编码方案，每个 Unicode 码占用 16 个比特位。 HashMap中改成containsKey和containsValue方法来替换 contains 方法。 File类是java中文件和目录路径名的抽象表示形式。Java中对文件进行读写操作的基本类是IO类。 有一个源代码，只包含import java.util.* ; 这一个import语句，我们不能访问 util 子目录下的类。 DBMS 中实现事务持久性的子系统是 恢复管理子系统 ceil：大于等于 x，并且与它最接近的数。floor：小于等于 x，且与 x 最接近的数。 java的访问权限有public、protected、private和default的，default不能修饰变量。 普通变量不能用 abstract 修饰，abstract 一般修饰类和方法。 数值型变量在默认情况下为int型，byte和short型在计算时会自动转换为int型计算，结果也是int 型。所以 a1*a2 的结果是 int 型的。 12341. byte a1 = 2, a2 = 4, a3;2. short s = 16;3. a2 = s;4. a3 = a1 * a2; stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。 实际使用通常差不多。 在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 只是读写文件，和文件内容无关的，一般选择字节流。 Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 Counter不是并发编程的同步器 类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。 在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能给定数组长度。 boolean类型不能和任何类型进行转换，会报出类型异常错误。 1234如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。 多线程是Java程序的并发机制，它能同步共享数、处理不同的事件。 if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 管道为空，读操作会被阻塞；管道满了，写操作会被阻塞，管道是内存中的，匿名管道只能单向；命名管道可以双向，可以有多个进程对其读；也可以有多个进程写，只不过不能同时写 会产生信息丢失不如说丢失精度，这样可能更容易明白，而精度丢失只会发生在从大范围到小范围的转换，比如说 int 转换成 double 或 float。 12341. 普通管道（PIPE）：通常有两种限制，一是单工，即只能单向传输；二是血缘，即常用于父子进程间（或有血缘关系的进程间）。2. 流管道（s_pipe）：去除了上述的第一种限制，实现了双向传输。3. 命名管道（name_pipe）：去除了上述的第二种限制，实现了无血缘关系的不同进程间通信。显然，要求是对于不同的服务器之间的通信，是要要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输 Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。 12345671. 尽量使用many-to-one，避免使用单项one-to-many2. 灵活使用单向one-to-many3. 不用一对一，使用多对一代替一对一4. 配置对象缓存，不使用集合缓存5. 一对多使用Bag 多对一使用Set6. 继承使用显示多态 HQL:from object polymorphism=&quot;exlicit&quot; 避免查处所有对象7. 消除大表，使用二级缓存 局部内部类前不能用修饰符public和private,protected 解决哈希冲突常用的两种方法是：开放定址法 和 链地址法 存根（Stub）与 动态链接 有关 泛型仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入就绪状态，不是运行状态 123456-Xmx：最大堆大小-Xms：初始堆大小-Xmn:年轻代大小-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。-Xms初始堆大小即最小内存值为10240m java 中的数据类型分为基本数据和引用数据类型，基本数据类型包括数值型（整数类型：int、short、long、byte，浮点类型：double、float）、布尔型（true）、字符型（char），引用数据类型包括类、接口、数组。 123456789在java.util包中提供了一些集合类，常用的有List、Set和Map类，其中List类和Set类继承了Collection接口。这些集合类又称为容器，长度是可变的，数组用来存放基本数据类型的数据，集合用来存放类对象的引用。 List接口、Set接口、Map接口以及Collection接口的主要特征如下： Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用。List接口继承了Collection接口，List接口允许存放重复的对象，排序方式为按照对象的插入顺序。 Set接口继承了Collection接口，Set接口不允许存放重复的对象，排序方式为按照自身内部的排序规则。 Map接口以键值对（key—value）的形式存放对象，其中键（key）对象不可以重复，值（value）对象可以重复，排序方式为按照自身内部的规则。C：Vector实现了List接口，即间接实现Collection接口D：Iterator是Java迭代器最简单的实现，没有实现Collection接口 1、三目运算是右结合的。2、&amp;不短路，&amp;&amp;短路。 123456基本类型数组: byte[],short[],int[] ,默认值为0, boolean[]默认值为falsefloat[],double[],默认值为0.0对象类型数组:默认值为null 37.123456789101112131415161718EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。 例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。 局部内部类 和局部变量一样不能用访问权限修饰符修饰。 1后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。 同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间 java 中的接口是多继承的，类是单继承的。 12345System.out.println(1+&quot;10&quot;+3+&quot;2&quot;);//11032System.out.println(1+2+&quot;10&quot;+3+&quot;2&quot;);//31032System.out.println(1+&quot;10&quot;+3+1+&quot;2&quot;);//110312System.out.println(1 + &quot;10&quot; + (3 + 1) + 1); // 11041在遇到string类型之前，int间使用 &quot;+&quot; 还是表示数值的相加，但是遇到第一个string后，后面就都是按string类型来了，变成字符串的拼接 Log4j的日志打印级别 不可以 在运行时重新设置 123451. CopyOnWriteArrayList适用于写少读多的并发场景2. ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 读与读之间可以并发执行。在读多写少的情况下可以提高效率3. ConcurrentHashMap是同步的HashMap，读写都加锁4. volatile只保证多线程操作的可见性，不保证原子性 String是个不可继承类（final修饰），也是个不可变类（内部char数组被final修饰）。StringBuffer和StringBuilder内部都是一般的动态数组，所以可变。前者是线程安全的，因为方法基本都被synchronized修饰了 一个.java文件中，可以有多个类，包括内部类和外部类。考虑到内部类的原因，一个.java文件可以中可以有多个public类。但是对于外部类而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）。 java继承中对构造函数是不继承的，只是显式或者隐式调用 1234567vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。statck：堆栈类，先进后出hashtable：就比hashmap多了个线程安全enumeration：枚举，相当于迭代器 123456789out-&gt;response.getWriterrequest -&gt;Service方法中的req参数response -&gt;Service方法中的resp参数session -&gt;request.getSessionapplication -&gt;getServletContextexception -&gt;Throwablepage -&gt;thispageContext -&gt;PageContextConfig -&gt;getServletConfig 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了 数据覆盖 的可能性，和 数据类型覆盖 并没有关系。 1234567891011121314151617public class Enclosingone &#123; //非静态内部类 public class InsideOne &#123;&#125; //静态内部类 public static class InsideTwo&#123;&#125;&#125; class Mytest02&#123; public static void main(String args [])&#123; Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象 Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象 &#125;&#125;内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a 就像int a 一样，至于静态内部类和非静态内部类new的时候有点区别 Outer.Inner a=new Outer().new Inner()（非静态，先有Outer对象才能有属性） Outer.Inner a=new Outer.Inner()要把Outer.Inner看成一部分，就像类变量一样 不能用 this 来访问静态变量。 设为x进制，用十进制表示方法13就是 1*x^1+3*x^0=x+3 Object 中有以下方法 getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize() 1234567891011121314151617181920212223242526272829303132333435use-a 是依赖关系has-a 一般是组合关系is-a 一般是继承关系```---title: Java专项练习（牛客网）date: 2018-06-17 15:13:01tags: - Javacomments: truecategories: Java---# Java专项练习（牛客网）### 第一题1. What will happen when you attempt to compile and run the following code?```javapublic class Test &#123; static &#123; int x = 5; &#125; static int x, y; public static void main(String[] args) &#123; x--; myMethod(); System.out.println(x + y + ++x); &#125; public static void myMethod() &#123; y = x++ + ++x; &#125;&#125; 解析： 静态代码块中的 x 是局部变量，这里不会有什么影响，不用管 静态成员变量 x, y 的初始值都为 0 然后执行 x-- 之后 x 的值为 -1 ,调用 myMethod() 方法，执行 x++ 之后 x 的值变为 0，x++ 的值为 -1 ，然后接着执行 ++x ，这时 x 的值为 1 ，++x 的值也为 1，所以这时 y的值为 0，所以 x + y + ++x 的值为 1 + 0 + 2 = 3 静态成员常量必须被初始化，静态变量和普通成员变量不用初始化 第二题 以下程序的运行结果是？ 123456789101112public class TestThread &#123; public static void main() &#123; Runnable r = new Runnable() &#123; public void run() &#123; System.out.println("foo"); &#125; &#125;; Thread t = new Thread(r); t.run(); System.out.println("bar"); &#125;&#125; 解析：这里需要注意的是，新建了一个线程之后，并没有调用 start() 方法，所以这里并不会体现多线程，就只是和调用普通的类的 run() 方法是一样的，所以这时候的执行结果是 foobar，如果此时新建的线程调用了 start() 方法，那么这时候，该线程会被加入到等待队列当中，并不会马上开始执行该线程，等待CPU调用它，才会开始执行，所以这时候就可能有两个答案 foobar 或 barfoo。 第三题下面哪个行为被打断不会导致InterruptedException：Thread.joinThread.sleepObject.waitCyclicBarrier.awaitThread.suspend 解析：抛InterruptedException的代表方法有： java.lang.Object 类的 wait 方法 java.lang.Thread 类的 sleep 方法 java.lang.Thread 类的 join 方法 CyclicBarrier是一个屏障类，它的await方法可以简单的理解为：等待多个线程同时到达之后才能继续进行，在此之前它就是这些线程的屏障，线程不能继续进行，而对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 interruptedException）以反常的方式离开。因此它被中断也是可以抛出interruptedException的，如果还是不清楚，查看一下JavaAPI，对于这个类介绍的清清楚楚。 第四题List，Set，Queue 都继承于 Collection，SortedMap 继承于 MapCollection —–List —–LinkedList 非同步 —-ArrayList 非同步，实现了可变大小的元素数组 —-Vector 同步 ——Stack —–Set 不允许有相同的元素 Map —–HashTable 同步，实现一个key–value映射的哈希表 —–HashMap 非同步， —–WeakHashMap 改进的HashMap，实现了“弱引用”，如果一个key不被引用，则被GC回收 第五题 启动一个线程的方法是： thread.start() 结束一个线程的方式通常用interrupt()方法 让线程等待另一个线程的方法是 thread.wait() 将一个线程标记成daemon线程，意味着当主线程结束，并且没有其它正在运行的非daemon线程时，该daemon线程也会自动结束。 第六题GenericServlet类的实现接口中包括了ServletConfig接口，但是它自身的init(ServletConfig config)方法又需要外界给它传递一个实现ServletConfig的对象，就是说GenericServlet和ServletConfig的依赖关系既是继承关系，也是一种关联关系。 第七题在GoF设计模式中，结构型模式有： 1.适配器模式 Adapter 适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。 2.桥接模式 Bridge 桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。 3.组合模式 Composite 组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 4.装饰模式 Decorator装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。 5.外观模式 Facade 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。 6.享元模式 Flyweight 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。. 享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。 7.代理模式 Proxy为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。 第八题java.lang.OutOfMemoryError: PermGen space查了一下为”永久代”内存大小不足，“永久代”的解释应该为JVM中的方法区，主要用于存储类信息，常量，静态变量，即时编译器编译后代码等。本错误仅限于Hotspot虚拟机，本区进行垃圾回收很少，不够直接加大简单粗暴。 java.lang.OutOfMemoryError: Requested array size exceeds VM limit直接翻译报错信息：数组过长导致堆内存溢出，加大堆内存或者减少数组长度。 java.lang.OutOfMemoryError: Java heap space堆内存不足，直接增大堆内存。 java.lang.OutOfMemoryError: nativeGetNewTLA参考这里 第九题需要注意的是，null从技术上讲是一个直接量，而不是关键字Java关键字 第十题下列程序的输出结果是什么？ 12345678910public class Test1&#123; public static void main(String args[])&#123; String a=&quot;1234&quot;; String b=&quot;1234&quot;; String c = new String(&quot;1234&quot;); System.out.println(a==b); System.out.println(a==c); System.out.println(a.equals(c)); &#125;&#125; 解析：重新说下String的equals方法，不是说所有类的equals方法都只判断值。例如Object的equals方法的作用和==是相同的，都是判断引用。只不过String类重写了Object的equals方法而已，代码如下123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String) anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 先判断地址是否相等，如果相等直接返回true.否则先判断是否是String类型的，如果是在判断每个字符是否相等，如果都相等返回true，其余情况返回false 第十一题静态变量只能在类中定义，不能在类的方法中定义，静态变量属于类而不属于方法参考资料： Java修饰符大汇总 第十二题持久带中主要存放用于存放静态类型数据，如 Java Class, Method 等， 与垃圾收集器要收集的Java对象关系不大。而heapspace分为年轻带和年老带年轻代的垃圾回收叫 Young GC， 年老代的垃圾回收叫 Full GC。在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象年老代溢出原因有 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存，既A B D选项持久代溢出原因 动态加载了大量Java类而导致溢出参考资料：JVM 堆内存设置原理 第十三题 环境变量可在编译source code时指定 在编译程序时，所能指定的环境变量可以包括class path javac一次可同时编译数个Java源文件 javac.exe能指定编译结果要置于哪个目录（directory） 第十四题在《java虚拟机》一书中明确讲了，释放掉占据的内存空间是由 gc 完成，但是程序员 无法明确强制其运行 ，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。 Java 把内存划分成两种：一种是 栈内存 ，另一种是 堆内存。在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配，当在一段代码块定义一个变量时，Java 就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java 会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。数组和对象 在没有引用变量指向它的时候，才变为垃圾，不能再被使用，但 仍然占据内存空间不放 ，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。 第十五题1234567891011121314151617181920212223242526272829package Wangyi;class Base&#123; public void method() &#123; System.out.println(&quot;Base&quot;); &#125; &#125;class Son extends Base&#123; public void method() &#123; System.out.println(&quot;Son&quot;); &#125; public void methodB() &#123; System.out.println(&quot;SonB&quot;); &#125;&#125;public class Test01&#123; public static void main(String[] args) &#123; Base base = new Son(); base.method(); base.methodB(); &#125;&#125; 这个程序编译会不通过，因为向上转型，父类的引用无法访问子类独有的方法 第十六题抽象类中可以有抽象方法，一般是非抽象子类在实例化时调用 第十七题垃圾回收包含的内容不少，但顺着下面的顺序捋清知识也并不难。首先要搞清垃圾回收的范围（栈需要GC去回收吗？），然后就是回收的前提条件如何判断一个对象已经可以被回收（这里只重点学习根搜索算法就行了），之后便是建立在根搜索基础上的三种回收策略，最后便是JVM中对这三种策略的具体实现。 1.范围：要回收哪些区域？ Java方法栈、本地方法栈以及PC计数器随方法或线程的结束而自然被回收，所以这些区域不需要考虑回收问题。Java堆和方法区是GC回收的重点区域，因为一个接口的多个实现类需要的内存不一样，一个方法的多个分支需要的内存可能也不一样，而这两个区域又对立于栈可能随时都会有对象不再被引用，因此这部分内存的分配和回收都是动态的。 2.前提：如何判断对象已死？ （1）引用计数法 引用计数法就是通过一个计数器记录该对象被引用的次数，方法简单高效，但是解决不了循环引用的问题。比如对象A包含指向对象B的引用，对象B也包含指向对象A的引用，但没有引用指向A和B，这时当前回收如果采用的是引用计数法，那么对象A和B的被引用次数都为1，都不会被回收。 下面是循环引用的例子，在Hotspot JVM下可以被正常回收，可以证实JVM采用的不是简单的引用计数法。通过-XX:+PrintGCDetails输出GC日志。 12345678910111213141516171819202122232425package com.cdai.jvm.gc; public class ReferenceCount &#123; final static int MB = 1024 * 1024; byte[] size = new byte[2 * MB]; Object ref; public static void main(String[] args) &#123; ReferenceCount objA = new ReferenceCount(); ReferenceCount objB = new ReferenceCount(); objA.ref = objB; objB.ref = objA; objA = null; objB = null; System.gc(); System.gc(); &#125; &#125; [Full GC (System) [Tenured: 2048K-&gt;366K(10944K), 0.0046272 secs] 4604K-&gt;366K(15872K), [Perm : 154K-&gt;154K(12288K)], 0.0046751 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] （2）根搜索 通过选取一些根对象作为起始点，开始向下搜索，如果一个对象到根对象不可达时，则说明此对象已经没有被引用，是可以被回收的。可以作为根的对象有：栈中变量引用的对象，类静态属性引用的对象，常量引用的对象等。因为每个线程都有一个栈，所以我们需要选取多个根对象。 附：对象复活 在根搜索中得到的不可达对象并不是立即就被标记成可回收的，而是先进行一次标记放入F-Queue等待执行对象的finalize()方法，执行后GC将进行二次标记，复活的对象之后将不会被回收。因此，使对象复活的唯一办法就是重写finalize()方法，并使对象重新被引用。 123456789101112131415161718192021222324252627282930313233package com.cdai.jvm.gc; public class DeadToRebirth &#123; private static DeadToRebirth hook; @Override public void finalize() throws Throwable &#123; super.finalize(); DeadToRebirth.hook = this; &#125; public static void main(String[] args) throws Exception &#123; DeadToRebirth.hook = new DeadToRebirth(); DeadToRebirth.hook = null; System.gc(); Thread.sleep(500); if (DeadToRebirth.hook != null) System.out.println(&quot;Rebirth!&quot;); else System.out.println(&quot;Dead!&quot;); DeadToRebirth.hook = null; System.gc(); Thread.sleep(500); if (DeadToRebirth.hook != null) System.out.println(&quot;Rebirth!&quot;); else System.out.println(&quot;Dead!&quot;); &#125; &#125; 要注意的两点是：第一，finalize()方法只会被执行一次，所以对象只有一次复活的机会。第二，执行GC后，要停顿半秒等待优先级很低的finalize()执行完毕。 3.策略：垃圾回收的算法 （1）标记-清除 没错，这里的标记指的就是之前我们介绍过的两次标记过程。标记完成后就可以对标记为垃圾的对象进行回收了。怎么样，简单吧。但是这种策略的缺点很明显，回收后内存碎片很多，如果之后程序运行时申请大内存，可能会又导致一次GC。虽然缺点明显，这种策略却是后两种策略的基础。正因为它的缺点，所以促成了后两种策略的产生。 （2）标记-复制将内存分为两块，标记完成开始回收时，将一块内存中保留的对象全部复制到另一块空闲内存中。实现起来也很简单，当大部分对象都被回收时这种策略也很高效。但这种策略也有缺点，可用内存变为一半了！ 怎样解决呢？聪明的程序员们总是办法多过问题的。可以将堆不按1:1的比例分离，而是按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了新生代。 从下图可以看到这三块区域如何配合完成GC的，具体的对象空间分配以及晋升请参加后面第6条补充。 为什么不是全部呢？如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是老年代的用处。当不够用时，这些对象将直接通过分配担保机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。 （3）标记-整理根据老年代的特点，采用回收掉垃圾对象后对内存进行整理的策略再合适不过，将所有存活下来的对象都向一端移动。 4.实现：虚拟机中的收集器 （1）新生代上的GC实现Serial：单线程的收集器，只使用一个线程进行收集，并且收集时会暂停其他所有工作线程（Stop the world）。它是Client模式下的默认新生代收集器。ParNew：Serial收集器的多线程版本。在单CPU甚至两个CPU的环境下，由于线程交互的开销，无法保证性能超越Serial收集器。Parallel Scavenge：也是多线程收集器，与ParNew的区别是，它是吞吐量优先收集器。吞吐量=运行用户代码时间/(运行用户代码+垃圾收集时间)。另一点区别是配置-XX:+UseAdaptiveSizePolicy后，虚拟机会自动调整Eden/Survivor等参数来提供用户所需的吞吐量。我们需要配置的就是内存大小-Xmx和吞吐量GCTimeRatio。 （2）老年代上的GC实现Serial Old：Serial收集器的老年代版本。Parallel Old：Parallel Scavenge的老年代版本。此前，如果新生代采用PS GC的话，老年代只有Serial Old能与之配合。现在有了Parallel Old与之配合，可以在注重吞吐量及CPU资源敏感的场合使用了。CMS：采用的是标记-清除而非标记-整理，是一款并发低停顿的收集器。但是由于采用标记-清除，内存碎片问题不可避免。可以使用-XX:CMSFullGCsBeforeCompaction设置执行几次CMS回收后，跟着来一次内存碎片整理。 5.触发：何时开始GC？ Minor GC（新生代回收）的触发条件比较简单，Eden空间不足就开始进行Minor GC回收新生代。而Full GC（老年代回收，一般伴随一次Minor GC）则有几种触发条件：（1）老年代空间不足（2）PermSpace空间不足（3）统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间 这里注意一点：PermSpace并不等同于方法区，只不过是Hotspot JVM用PermSpace来实现方法区而已，有些虚拟机没有PermSpace而用其他机制来实现方法区。 6.补充：对象的空间分配和晋升 （1）对象优先在Eden上分配 （2）大对象直接进入老年代 虚拟机提供了-XX:PretenureSizeThreshold参数，大于这个参数值的对象将直接分配到老年代中。因为新生代采用的是标记-复制策略，在Eden中分配大对象将会导致Eden区和两个Survivor区之间大量的内存拷贝。 （3）长期存活的对象将进入老年代 对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度 （默认为15岁）时，就会晋升到老年代中。 第十八题 功能性注释嵌在源程序中，用于说明程序段或语句的功能以及数据的状态。 可使用空行或缩进，以便很容易区分注释和程序。 修改程序也应修改注释。 第十九题 线程运行速度与线程的优先级无关。 第二十题超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中： 传送协议。服务器。端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）路径。（以“/”字符区别路径中的每一个目录名称）查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）典型的统一资源定位符看上去是这样的： (带方括号[]的为可选项)：protocol :// hostname[:port] / path / [;parameters][?query]#fragment 第二十一题java中的字符串存储在 字符串常量区，不会改变，发生改变 是会 新创建一个对象StringBuffer是 线程安全的StringBuilderStringBuilder跟StringBuffer功能相同，区别是StringBuilder 不是 线程安全的StringBuilder和StringBuffer底层都是以 字符数组 存放的，可以 修改 内容 第二十二题一般关系数据模型和对象数据模型之间有以下对应关系：表对应类 ，记录对应对象 ，表的字段对应类的属性 第二十三题sleep和wait的区别有： 这两个方法来自不同的类分别是Thread和Object 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 1234synchronized(x)&#123; x.notify() //或者wait()&#125; sleep必须捕获异常，而 和 notifyAll``` 不需要捕获异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556### 第二十四题编译不会编译注释中的内容。javac编译后的字节码文件中也不会出现自己手打的注释。 ### 第二十五题Java 提供的事件处理模型是一种人机交互模型。它有三个基本要素：1) 事件源（Event Source）：即事件发生的场所，就是指各个组件，如按钮等，点击按钮其实就是组件上发生的一个事件；2) 事件（Event）：事件封装了组件上发生的事情，比如按钮单击、按钮松开等等；3) 事件监听器（Event Listener）：负责监听事件源上发生的特定类型的事件，当事件到来时还必须负责处理相应的事件；### 第二十六题对象的初始化方式： 1. new时初始化； 2. 静态工厂 newInstance； 3. 反射Class.forName()； 4. clone方式； 5. 反序列化； ### 第二十七题1. 类方法是指类中被 `static` 修饰的方法，`无` this指针。2. 类方法是可以调用其他类的static方法的。3. 可以在类方法中 `生成实例对象` 再调用实例方法。### 第二十八题在Java中，函数代码小，频繁调用的情况下适合采用内联函数在说内联函数之前，先说说函数的调用过程。 调用某个函数实际上将程序执行顺序转移到该函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到 转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保 存地址继续执行。也就是通常说的压栈和出栈。因此，函数调用要有一定的时间和空间方面的开销。那么对于那些函数体 代码不是很大，又频繁调用的函数来说，这个时间和空间的消耗会很大。 那怎么解决这个性能消耗问题呢，这个时候需要引入内联函数了。内联函数就是在程序编译时，编译器将程序中出现 的内联函数的调用表达式用内联函数的函数体来直接进行替换。显然，这样就不会产生转去转回的问题，但是由于在编译 时将函数体中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时 那么大，可见它是以目标代码的增加为代价来换取时间的节省。 在大学里学习写C代码时，我们都学到将一些简短的逻辑定义在宏里。这样做的好处是，在编译器编译的时候会将用 到该宏的地方直接用宏的代码替换。这样就不再需要象调用方法那样的压栈、出栈，传参了。性能上提升了。内联函数的 处理方式与宏类似，但与宏又有所不同，内联函数拥有函数的本身特性（类型、作用域等等） 写过C++代码的应该都知道，在C++里有个内联函数，使用inline关键字修饰。另外，写在Class定义内的函数也会被 编译器视为内联函数。 那么，在java中的内联函数长什么模样呢？在java中使用final关键字来指示一个函数为内联函数，例如：```javapublic final void method1() &#123; //TODO something &#125; 这个指示并不是必需的。final关键字只是告诉编译器，在编译的时候考虑性能的提升，可以将final函数视为内联函数。但最后编译器会怎么处理，编译器会分析将final函数处理为内联和不处理为内联的性能比较了。 第二十九题double m = 3; // 正确double m = 3.0; // 正确Double m = 3; // 错误Double m = 3.0; // 正确int m = 0.0 // 错误float m = 3; // 正确float m = 3.0; // 错误，需要强制类型转换 第三十题算法包括0个或多个输入，1个或多个输出，中间有穷个处理过程。存储结构不属于算法结构 下面是维基百科对算法的定义输入：一个算法必须有零个或以上输入量。输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地匹配要求或期望，通常要求实际运行结果是确定的。有限性：依据图灵的定义，一个算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定算法必须在有限个步骤内完成任务。有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。 第三十一题下列程序输出结果是：1234567891011121314151617public class Example &#123; String str = new String(&quot;good&quot;); char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;; public static void main(String args[]) &#123; Example ex = new Example(); ex.change(ex.str, ex.ch); System.out.print(ex.str + &quot; and &quot;); System.out.print(ex.ch); &#125; public static void change(String str, char ch[]) &#123; str = &quot;test ok&quot;; ch[0] = &apos;g&apos;; &#125;&#125; 最后的输出结果是： good and gbc 分析：这里需要注意的是，在java中只有按值传递，不管是基本类型还是对象，并没有按引用传递（详情见119页Java核心技术卷I），change函数被调用时，第一个形参str接收了类的成员变量str的值（虽然名称都是str，但是却是两个独立的String类型的引用变量），注意这两个str自身都是变量且都指向了堆内存中的String对象”good”，当我们在change函数内部将str指向了另一个String对象”test ok”后，类的成员变量str仍然保持指向”good”，所以最终打印出来就是”good”；对于第二个形参ch，它也是接收了类的成员变量ch的值拷贝，这一点和str没有差别，即两个ch都指向了字符数组{ ‘a’, ‘b’, ‘c’ }的首地址，但是ch[0]表示的是字符数组中’a’的地址，修改了它也就修改了字符数组的第一个元素，这个改变在change函数返回之后也会存在。所以本题中两个形参传参的本质区别在于，修改str只是将形参指向了新的对象，对外部的实参没有任何影响，而修改ch[0]是实实在在的修改了字符数组的首元素。扩展： 可以试验一下，在Example中再定义一个字符数组char[] ch2={‘d’};然后在change函数中把ch[0] = ‘g’;这句改成ch=ch2;，那么就会和str传参一样的，change函数返回后不会对类的成员ch有任何影响。 本题和“String类是一个final类，不能被继承”以及“String底层的字符数组被声明为private final char value[];所以其值不能被修改”这些String的特性无关。 我们平时交换数组中的两个元素时，一般定义swap方法为 void swap(int[] a, int i, int j)，想想看为什么能达到目的？如果不使用数组，能实现交换吗？数组中存放的不是基本类型变量而是引用类型变量呢？ 第三十二题A、Semaphore：类，控制某个资源可被同时访问的个数;B、ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；C、 Future：接口，表示异步计算的结果；D、 CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。 第三十三题在单行文本输入区(Textfield)构件上可能发生的事件包括 FocusEvent 焦点事件，所对应的事件监听器是 FocusListener ； ActionEvent 动作事件，所对应的事件监听器是 ActionListener ； MouseEvent 鼠标事件，所对应的事件监听器是 MouseMotionListener 。 第三十四题HttpServlet容器响应Web客户请求流程如下： Web客户向Servlet容器发出Http请求； Servlet容器解析Web客户的Http请求； Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息； Servlet容器创建一个HttpResponse对象； Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象； HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息； HttpServlet调用HttpResponse的有关方法，生成响应数据； Servlet容器把HttpServlet的响应结果传给Web客户。 第三十五题 ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized; HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Cllectio Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList； SimpleDateFormat是线程不安全的 第三十六题事务属性的种类：传播行为、隔离级别、只读和事务超时 传播行为定义了被调用方法的事务边界。 传播行为 意义 PROPERGATION_MANDATORY 表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常 PROPAGATION_NESTED 表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED看起来没什么俩样 PROPAGATION_NEVER 表示方法不能运行在一个事务中，否则抛出异常 PROPAGATION_NOT_SUPPORTED 表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起 PROPAGATION_REQUIRED 表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务 PROPAGATION_REQUIRES_NEW 表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起 PROPAGATION_SUPPORTS 表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中 隔离级别在操作数据时可能带来 3 个副作用，分别是脏读、不可重复读、幻读。为了避免这 3 中副作用的发生，在标准的 SQL 语句中定义了 4 种隔离级别，分别是未提交读、已提交读、可重复读、可序列化。而在 spring 事务中提供了 5 种隔离级别来对应在 SQL 中定义的 4 种隔离级别，如下： 隔离级别 意义 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别 ISOLATION_READ_UNCOMMITTED 允许读取未提交的数据（对应未提交读），可能导致脏读、不可重复读、幻读 ISOLATION_READ_COMMITTED 允许在一个事务中读取另一个已经提交的事务中的数据（对应已提交读）。可以避免脏读，但是无法避免不可重复读和幻读 ISOLATION_REPEATABLE_READ 一个事务不可能更新由另一个事务修改但尚未提交（回滚）的数据（对应可重复读）。可以避免脏读和不可重复读，但无法避免幻读 ISOLATION_SERIALIZABLE 这种隔离级别是所有的事务都在一个执行队列中，依次顺序执行，而不是并行（对应可序列化）。可以避免脏读、不可重复读、幻读。但是这种隔离级别效率很低，因此，除非必须，否则不建议使用。 只读如果在一个事务中所有关于数据库的操作都是只读的，也就是说，这些操作只读取数据库中的数据，而并不更新数据，那么应将事务设为只读模式（ READ_ONLY_MARKER ） , 这样更有利于数据库进行优化 。 因为只读的优化措施是事务启动后由数据库实施的，因此，只有将那些具有可能启动新事务的传播行为 (PROPAGATION_NESTED 、 PROPAGATION_REQUIRED 、 PROPAGATION_REQUIRED_NEW) 的方法的事务标记成只读才有意义。 如果使用 Hibernate 作为持久化机制，那么将事务标记为只读后，会将 Hibernate 的 flush 模式设置为 FULSH_NEVER, 以告诉 Hibernate 避免和数据库之间进行不必要的同步，并将所有更新延迟到事务结束。 事务超时如果一个事务长时间运行，这时为了尽量避免浪费系统资源，应为这个事务设置一个有效时间，使其等待数秒后自动回滚。与设置“只读”属性一样，事务有效属性也需要给那些具有可能启动新事物的传播行为的方法的事务标记成只读才有意义。 第三十六题ArrayList的构造函数总共有三个： ArrayList()构造一个初始容量为 10 的空列表。 ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 ArrayList(int initialCapacity)构造一个具有 指定初始容量 的空列表。调用的是第三个构造函数，直接初始化为大小为20的list，没有扩容，所以选择A 参考资料： 常用集合的默认初始容量和扩容的原因 ArrayList动态扩容机制 第三十七题&gt;&gt; 为带符号右移，右移后左边的空位被填充为 符号位&gt;&gt;&gt; 为不带符号右移，右移后左边的空位被填充为 0没有 &lt;&lt;&lt; 因为 &lt;&lt; 后右边 总是补0 第三十八题12345678910111213package NowCoder;class Test &#123; public static void hello() &#123; System.out.println("hello"); &#125;&#125;public class MyApplication &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Test test = null; test.hello(); &#125;&#125; 该代码能正常运行解析：类方法（就是静态方法）不依附于对象，所以当然可以正常运行 引用不同于指针，引用中既包含指向对象的指针、又包含指向类的指针，test中指向对象的指针确实为空，但指向Test的指针可不为空 第三十九题Web容器在启动时为每个Web应用创建一个ServletContext对象，ServletConfig对象中维护了ServletContext的引用，开发人员在编写servlet时，可以通过ServletConfig.getServletContext方法获得ServletContext对象。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象来实现通讯。ServletContext对象通常也被称之为context域对象。 多个Servlet通过ServletContext对象实现数据共享。 在InitServlet的Service方法中利用ServletContext对象存入需要共享的数据ServletContext context = this.getServletContext();context.setAttribute(“name”, “haha”); 在其它的Servlet中利用ServletContext对象获取共享的数据ServletContext context = this.getServletContext();String name = context.getAttribute(“name”); 获取WEB应用的初始化参数。 在DemoServlet的doPost方法中测试获取初始化参数的步骤如下: ServletContext context = this.getServletContext();String url = context.getInitParameter(“url”); 第四十题jvm虚拟机的功能： 通过 ClassLoader 寻找和装载 class 文件 解释字节码成为指令并执行，提供 class 文件的运行环境 进行运行期间垃圾回收 提供与硬件交互的平台 第四十一题在Java中，对于不再使用的内存资源，如调用完成的方法，不是 由 垃圾回收器 自动将其释放，而是方法调用时，会创建 栈帧 在栈中，调用完是 程序自动出栈释放 第四十二题Spring并没有提供一个AOP方式的日志系统，而是我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。Spring是一系列轻量级Java EE框架的集合，比如： spring context ,spring aop ,springMVC ,spring ORm ,spring web ,spring dao,core context Spring中包含一个“依赖注入”模式的实现使用Spring可以实现声明式事务 第四十三题HashTable和HashMap区别 继承不同。 12public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 第四十四题在Java中，关于接口实现类的方法这里还有几点需要注意： 接口中的方法如果抛出了异常，那么实现类中的方法跑出的异常必须 &lt;= 接口中的方法抛出的异常 接口的中方法的返回值类型如果是Person，它的一个子类是Student，父类是Animal，那么实现类中的方法的返回值类型必须是 Student 或 Person，不能是Animal 实现类中的方法名、参数类型个数顺序都必须和接口中的方法相同 接口中的方法的默认权限是 public ，那么实现类重写后的方法的权限 只能是public 第四十五题String a = “llo”;String str1 = “hello”;String str2 = “he” + new String(“llo”);String str3 = “he” + “llo”;String str4 = “he” + a;System.out.println(str1 == str2); // falseSystem.out.println(str1 == str3); // trueSystem.out.println(str1 == str4); // false 解析：String str1= “hello”, String str2=”he”+”llo”;之所以str1\=\=str2返回true是因为两者都是在字符串常量池中（由于初始化就会在此区域分布内存）而常量池中的有个与栈区类似的特性，就是当str2指向的常量在常量区已存在时，他不会创建新的内存空间来存此常量，而是指向已有常量的内存（应该是以此节约空间），此时str1与str2这两个引用变量的值都是存”hello”的内存空间地址，但是String str3= “he”+a;String a=”llo”;时str1\=\=str3返回的为false，是因为：str1指向的hello在编译期一如既往的还是分配在常量区内，a指向的llo也在常量区，虽然str3也是初始化但是编译器无法判断a这货到底是什么个情况，进而不会将str3的等号右侧声明在常量区内，而是在通过构造时在堆区中的非常量池外的内存中声明，至此str3与str1不止是分配内存的时期不同（一个在编译期，一个在运行期）而且在内存空间的区域也不同，上面最高票答案只区分了时间没区分空间。 第四十六题java语言的下面几种数组复制方法中，哪个效率最高？ 复制的效率 System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for 循环，这个有兴趣自己测试一下就知道了。这里面在System类源码中给出了arraycopy的方法，是native方法，也就是本地方法，肯定是最快的。而Arrays.copyOf(注意是Arrays类，不是Array)的实现，在源码中是调用System.arraycopy的，多了一个步骤，肯定就不是最快的 第四十七题1234567891011121314package algorithms.com.guan.javajicu; public class Inc &#123; public static void main(String[] args) &#123; Inc inc = new Inc(); int i = 0; inc.fermin(i); // 这句话其实并没有用，java中参数传递都是按值传递 i = i++; // 这里需要注意的是 i = i++ , i = ++i 和 i = i + 1 并不相同，前者i的值是 0 ，中间i的值是 1， 后者i的值是 1 System.out.println(i); &#125; void fermin(int i)&#123; i++; &#125; &#125; 最终的运行结果是： 0 第四十八题在java中线程是有分优先等级的所以优先级不能相同Thread实现了Runnable接口是一个类不是接口实现多线程的三种方式，一种是继承Thread类使用此方式就不能继承其他的类了。还有两种是实现Runnable接口或者实现Callable接口 第四十九题Servlet生命周期 Servlet的生命周期一般可以用三个方法来表示： init()：仅执行一次，负责在装载Servlet时初始化Servlet对象 service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。 destroy()：在停止并且卸载Servlet时执行，负责释放资源 初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。 第五十题 从地址栏显示来说 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器. 浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 从数据共享来说 forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据. 从运用地方来说 forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等. 从效率来说 forward:高. redirect:低. 第五十一题 有两个类 A 和 B，B 继承 A，且 A 和 B 中均有静态代码块和非静态代码块，那么获取 B 的一个实例时，相应的执行顺序如下。先执行 A 类中的静态代码块，再执行 B 类中的代码块接着执行 A 类中的非静态代码块和构造函数最后执行 B 类中的非静态代码块和构造和函数。 第五十二题 java 中访问权限 作用域 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 第五十三题中间件运行于操作系统之上，应用软件之下，而不是操作系统内核之中。中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理） 第五十四题1234567891011121314151617181920A：设置HTTP头标 response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); //三秒刷新页面一次B：设置cookieCookie c1 = new Cookie(&quot;username&quot;,&quot;only&quot;);response.addCookie(c1);C（错误）：读取路径信息,request读取路径信息从request获取各种路径总结request.getRealPath(&quot;url&quot;); // 虚拟目录映射为实际目录request.getRealPath(&quot;./&quot;); // 网页所在的目录request.getRealPath(&quot;../&quot;); // 网页所在目录的上一层目录request.getContextPath(); // 应用的web目录的名称D：输出返回数据HttpServleteResponse.getOutputStream().write(); 第五十五题关于PreparedStatement 和 Statement 描述 PreparedStatement 比 Statement 执行效率更高 PreparedStatement 会预编译 SQL 语句 Statement 每次都会解析/编译 SQL 语句确立并优化数据获取路径 第五十六题关于运算符优先级 单目&gt;运算&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 第五十七题当程序执行到try{}语句中的return方法时，它会干这么一件事，将要返回的结果存储到一个临时栈中，然后程序不会立即返回，而是去执行finally{}中的程序。并不是说return后面的语句不执行，只是要等到finally{}中的语句（不存在return语句）执行完后，再返回。如果finally{}里也有一个return，那么在执行这个return时，就会更新临时栈中的值。 第五十八题一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 禁止进行指令重排序。 volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。而对该变量的修改，volatile并不提供原子性的保证。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况多线程下计数器必须使用锁保护 第五十九题int x = 1, float y = 2, 则表达式 x / y 的值为：0.5 解析： 当多个数字进行运算的时候，最终结果以 最高精度 的为准 参考：①float x = 1；与float x = 1.0f，这两种对于float类型的变量来说定义的方式都是正确的，也是比较常见的笔试题里面考察类型转换的例子，当第一种情况时，是将低精度int向上转型到float，是由于java的特性导致而不需要进行强制转换，而第二种情况则是比较正式的对于float变量的定义，由于这种类型本身在工作项目中并不常见，常用的带小数的数字我们一般都直接使用double类型，而double类型直接定义是没有问题的：double x = 1.0。而由于float的精度没有double类型高，因此必须对其进行显示的格式书写，如果没有这个f，就默认是double类型了。当然double x = 1.0d也是正确的命名，不信你可以尝试，虽然这是一个令人窒息的操作。②当多个精度的数字同时进行运算时，最终结果以最高精度为准。在多数情况下，整数和小数的各级混合运算中，一般结果都是double类型的。但就本题而言，结果是float类型的，因为x，y两个数字精度最高的就是float，所以最终结果是0.5，并且这个0.5是float类型的。为什么说不是double类型呢，当然如果你这样处理：double m = x/y，当然m是double类型的，也不会报错，而如果你写成int m = x/y，编译器报错提示的时候就会让你转换成float或者进行强制转换成int，他是不会提示你转换成double的，尽管这么写并没有报错，原因就是① 第六十题 在 HashMap 中，前后插入两个相同的键值，后一个键值对应的value会覆盖前一个键值的value 第六十一题123456789101112131415161718192021222324252627282930313233343536public class Test &#123; int i = 1; static int b = 3; private String a = "333"; private static String c = "ffafd"; class Inner1 &#123; void test() &#123; System.out.println(i); System.out.println(b); System.out.println(a); System.out.println(c); &#125; /** * 非静态内部类 * 可以 访问外围类的非静态属性，包括私有属性 * 可以 访问外围类的静态属性，包括私有静态属性 */ &#125; static class Inner1 &#123; void test() &#123; System.out.println(i); // 会报错 System.out.println(b); System.out.println(a); // 会报错 System.out.println(c); &#125; /** * 静态内部类 * 不可以 访问外围类的非静态属性，包括私有属性 * 可以 访问外围类的静态属性，包括私有静态属性 */ &#125; &#125; 第六十二题抽象方法 不能 有方法体，同时也 不能 有大括号，以分号结尾。 第六十三题Java 中创建数组的几种写法 1234float f[][] = new float[6][6];float []f[] = new float[6][6];float [][]f = new float[6][6];float [][]f = new float[6][]; 第六十四题异常相关 throws 用于在方法上 声明 要抛出的异常，不是用来抛出异常的 throw 用于抛出异常 第六十五题内部类（也叫成员内部类）有四种访问权限 第六十六题Object 对象中的方法 1．clone方法 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。 2．getClass方法 final方法，获得运行时类型。 3．toString方法 该方法用得比较多，一般子类都有覆盖。 4．finalize方法 该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。 5．equals方法 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。 6．hashCode方法 该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。 一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。 7．wait方法 wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。 调用该方法后当前线程进入睡眠状态，直到以下事件发生。 （1）其他线程调用了该对象的notify方法。 （2）其他线程调用了该对象的notifyAll方法。 （3）其他线程调用了interrupt中断该线程。 （4）时间间隔到了。 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。 8．notify方法 该方法唤醒在该对象上等待的某个线程。 9．notifyAll方法 该方法唤醒在该对象上等待的所有线程。 第六十七题以下表达式都是正确的 12long i = 0xfffL;double i = 0.9339d;(一般后面不用加 d, 默认就是 d) 第六十八题 hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全 Arrays.asList() 将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。 加载驱动方法 1231.Class.forName(&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;);2. DriverManager.registerDriver(new com.mysql.jdbc.Driver());3.System.setProperty(&quot;jdbc.drivers&quot;, &quot;com.mysql.jdbc.Driver&quot;); Jsp只会在客户端第一次发请求的时候被编译，之后的请求不会再编译，同时tomcat能自动检测jsp变更与否，变更则再进行编译。第一次编译并初始化时调用： init() ；销毁调用： destroy() 。在整个jsp生命周期中均只调用一次。service()方法是接收请求，返回响应的方法。每次请求都执行一次，该方法被HttpServlet封装为doGet和doPost方法创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。(1)加载：容器通过类加载器使用servlet类对应的文件加载servlet(2)创建：通过调用servlet构造函数创建一个servlet对象(3)初始化：调用init方法初始化(4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求(5)卸载：调用destroy方法让servlet自己释放其占用的资源 Cookie是Web服务器发送给客户端的一小段信息，客户端请求时，可以读取该信息发送到服务器端关闭浏览器意味着临时会话ID丢失，但所有与原会话关联的会话数据仍保留在服务器上，直至会话过期在禁用Cookie时可以使用URL重写技术跟踪会话 第六十九题就是源Ip地址，目标IP地址，源端口号和目标端口号的组合服务器端：ServerSocket提供的实例1ServerSocket server= new ServerSocket(端口号) 客户端：Socket提供的实例1Socket soc=new Socket(ip地址，端口号) 第七十题ResultSet跟普通的数组不同，索引从1开始而不是从0开始 第七十一题12345678910public interface Test &#123; public void fun(); abstract void fun2(); static void fun3() &#123; System.out.println(&quot;java8 新特性&quot;); &#125; default void fun4() &#123; System.out.println(&quot;java8 新特性+1&quot;); &#125;&#125; 第七十二题 静态内部类才可以声明静态方法 静态方法不可以使用非静态变量 抽象方法不可以有函数体 第七十三题Java字节码是Java源文件编译产生的中间文件，java虚拟机是可运行java字节码的假想计算机，java的跨平台性也是相对与其他编程语言而言的，先介绍一下c语言的编译过程吧先是C语言源程序 也就是c的文件经过C编译程序编译后，生成windows可执行文件exe文件，然后在windows中执行。再介绍java的编译过程先是java源程序扩展名为java的文件，由java编译程序将java字节码文件，就是class文件然后在java虚拟机中执行。机器码是由CPU来执行的。Java编译后是字节码， 电脑只能运行机器码。Java在运行的时候把字节码变成机器码。C/C++在编译的时候直接编译成机器码。 第七十四题WSDL 可描述网络服务（Web Services）WSDL 指网络服务描述语言 (Web Services Description Language)。WSDL 是一种使用 XML 编写的文档。这种文档可描述某个 Web service。它可规定服务的位置，以及此服务提供的操作（或方法） 第七十五题 intValue()是把Integer对象类型变成int的基础数据类型 parseInt()是把String 变成int的基础数据类型 Valueof()是把String 转化成Integer对象类型 第七十六题堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。 年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收永久代：存储的是final常量，static变量，常量池。str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回 第七十七题A. Vector相当于一个线程安全的ListB. HashMap是非线程安全的，其对应的线程安全类是HashTableC. Arraylist是非线程安全的，其对应的线程安全类是VectorD. StringBuffer是线程安全的，相当于一个线程安全的StringBuilderE. Properties实现了Map接口，是线程安全的 第七十八题 构造函数是不能继承的，只是用来在子类调用,（如果父类没有无参构造函数，创建子类时，必须在子类构造函数代码体的第一行显式调用父类的有参数构造函数，否则不能编译）; 如果父类没有有参构造函数,那么在创建子类时可以不显式调用父类构造函数,系统会默认调用父类的无参构造函数super(); 如果父类没有无参构造函数,那系统就调不了默认的无参构造函数了,所以不显示调用编译也就无法通过了 补充说明： 在java中,创建有参构造函数后,系统就不在有默认的无参构造函数 如果父类中没有任何构造函数,系统会默认有一个无参的构造函数 第七十九题A. Thread可以被继承，用于创建新的线程B. Number类可以被继承，Integer，Float，Double等都继承自Number类C. Double类的声明为1public final class Doubleextends Numberimplements Comparable final生明的类不能被继承D. Math类的声明为1public final class Mathextends Object 不能被继承E. ClassLoader可以被继承，用户可以自定义类加载器 第八十题枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型，上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：123456789101112131415161718192021222324252627private AccountType() &#123; System.out.println(&quot;It is a account type&quot;); &#125;会变成：private AccountType(String s, int i) &#123; super(s,i); System.out.println(“It is a account type”); &#125;而在这个类中，会添加若干字段来代表具体的枚举类型：public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT;而且还会添加一段static代码段：static&#123; SAVING = new AccountType(&quot;SAVING&quot;, 0); CURRENT = new AccountType(&quot;CURRENT&quot;, 0); $VALUES = new AccountType[]&#123; SAVING, FIXED, CURRENT &#125; &#125;以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍 第八十一题for 循环的执行顺序 12345678910111213public class Print&#123; static boolean out(char c)&#123; System.out.println(c); return true; &#125; public static void main(String[] argv)&#123; int i = 0; for(out('A');out('B') &amp;&amp; (i&lt;2);out('C'))&#123; i++; out('D'); &#125; &#125;&#125; 最后的运行结果是：ABDCBDCB12345678910for循环执行开始首先执行out(&apos;A&apos;) 输出A；然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2)此时输出B，i=0，判断条件为真，执行for循环的循环体；执行i++，out(&apos;D&apos;)，输出D i=1；执行out(&apos;C&apos;),输出C 然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2) 此时输出B，i=1 判断条件为真 ，执行for循环的循环体；执行i++，out(&apos;D&apos;)，输出D i=2；执行out(&apos;C&apos;),输出C 然后执行out(&apos;B&apos;)&amp;&amp;(i&lt;2) 此时输出B，i=2，不满足i&lt;2 判断条件为假 ，跳出循环；所以结果为ABDCBDCB 第八十二题010 八进制 80x8 十六进制 8 第八十三题12345678910public class StringDemo&#123; private static final String MESSAGE="taobao"; public static void main(String [] args) &#123; String a ="tao"+"bao"; String b="tao"; String c="bao"; System.out.println(a==MESSAGE); System.out.println((b+c)==MESSAGE); &#125;&#125; 运行结果： 这题是在考编译器的优化，hotspot中 编译时”tao”+”bao”将直接变成”taobao”，b+c则不会优化，因为不知道在之前的步骤中bc会不会发生改变，而针对b+c则是用语法糖，新建一个StringBuilder来处理 第八十四题父类没有无参的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数 第八十五题12345String x=&quot;fmn&quot;;x.toUpperCase();String y=x.replace(&apos;f&apos;,&apos;F&apos;);y=y+&quot;wxy&quot;;System.out.println(y); 解析：String x=”fmn”; “fmn”是在常量池里的不可变对象。x.toUpperCase(); 在堆中new一个”FMN”对象，但无任何引用指向它。String y=x.replace(‘f’,’F’); 在堆中 new一个”Fmn”对象，y指向它。y=y+”wxy”; 在堆中 重新new一个”Fmnwxy”对象， 修改y指向，现在y指向它。 第八十六题数组不是基本类型，在java中，数据类型就分为基本数据类型(即原生类)和引用数据类型，所以数组不是原生类。 第八十七题序列化相关 一、序列化使用场景对象的序列化：目的：将一个具体的对象进行持久化，写入到硬盘上。（注意：静态数据不能被序列化，因为静态数据不在堆内存中，而是在静态方法区中）Serializable：用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。 二、非序列化使用场景如何将非静态的数据不进行序列化？用transient 关键字修饰此变量即可。使用场景：为了安全起见，有时候我们不需要在网络间传输一些数据（如身份证号码，密码，银行卡号等） java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 第八十八题标识符是以字母开头的字母数字序列：数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；字母、数字等字符的任意组合，不能包含+、- *等字符；不能使用关键字；大小写敏感 第八十九题动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=”included.jsp” flush=”true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。 静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=”included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。 以下是对 include 两种用法的区别 ， 主要有两个方面的不同 ;1234567一 : 执行时间上 :&lt;%@ include file=&quot;relativeURI&quot;%&gt; 是在翻译阶段执行&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 在请求处理阶段执行 .二 : 引入内容的不同 :&lt;%@ include file=&quot;relativeURI&quot;%&gt;引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 .&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 引入执行页面或 servlet 所生成的应答文本 . 第九十题1234567891011121314151617181920212223242526272829public class Demo &#123; public static void main(String args[]) &#123; String str1 = new String(&quot;hello&quot;); String str2 = new String(&quot;hello&quot;); String str3 = &quot;hello&quot;; String str4 = &quot;hello&quot;; String str5 = &quot;he&quot;+&quot;llo&quot;; String str6 = &quot;he&quot;; String str7 = &quot;llo&quot;; System.out.println(str1==str2); System.out.println(str1==str3); System.out.println(str3==str4); System.out.println(str3==&quot;hello&quot;); System.out.println(str4==(str6+str7)); &#125;&#125;上面代码的输出结果是：falsefalsetruetruefalse1String str1 = new String(&quot;hello&quot;);这种方式创建的字符串，和正常创建对象一样，保存在堆区。1String str3 = &quot;hello&quot;;这种方式创建的字符串，保存在字符串常量区。 第九十一题InputStreamReader(InputStream in, Charset cs)创建使用给定字符集的 InputStreamReader。 第九十二题Servlet 与 CGI 的比较 和CGI程序一样，Servlet可以响应用户的指令(提交一个FORM等等)，也可以象CGI程序一样，收集用户表单的信息并给予动态反馈(简单的注册信息录入和检查错误)。然而，Servlet的机制并不仅仅是这样简单的与用户表单进行交互。传统技术中，动态的网页建立和显示都是通过CGI来实现的，但是，有了Servlet,您可以大胆的放弃所有CGI(perl?php?甚至asp!)，利用Servlet代替CGI,进行程序编写。 当用户浏览器发出一个Http/CGI的请求，或者说 调用一个CGI程序的时候，服务器端就要新启用一个进程 (而且是每次都要调用)，调用CGI程序越多(特别是访问量高的时候)，就要消耗系统越多的处理时间，只剩下越来越少的系统资源，对于用户来说，只能是漫长的等待服务器端的返回页面了，这对于电子商务激烈发展的今天来说，不能不说是一种技术上的遗憾。而Servlet充分发挥了服务器端的资源并高效的利用。每次调用Servlet时并不是新启用一个进程 ，而是在一个Web服务器的进程敏感词享和分离线程，而线程最大的好处在于可以共享一个数据源，使系统资源被有效利用。 传统的CGI程序，不具备平台无关性特征，系统环境发生变化，CGI程序就要瘫痪，而Servlet具备Java的平台无关性，在系统开发过程中保持了系统的可扩展性、高效性。 传统技术中，一般大都为二层的系统架构，即Web服务器+数据库服务器，导致网站访问量大的时候，无法克服CGI程序与数据库建立连接时速度慢的瓶颈，从而死机、数据库死锁现象频繁发生。而我们的Servlet有连接池的概念，它可以利用多线程的优点，在系统缓存中事先建立好若干与数据库的连接，到时候若想和数据库打交道可以随时跟系统”要”一个连接即可，反应速度可想而知。 第九十四题 标准ASCII只使用7个bit，扩展的ASCII使用8个bit。 ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xFFFF来编码，即扩展的ASCII编码。不同 ANSI 编码之间互不兼容。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。 ANSI通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符，即ASCII码 ASCII码包含一些特殊空字符 第九十五题 在Java中，先继承再实现 java 的字符类型采用的是 Unicode 编码方案，每个 Unicode 码占用 16 个比特位。 HashMap中改成containsKey和containsValue方法来替换 contains 方法。 File类是java中文件和目录路径名的抽象表示形式。Java中对文件进行读写操作的基本类是IO类。 有一个源代码，只包含import java.util.* ; 这一个import语句，我们不能访问 util 子目录下的类。 DBMS 中实现事务持久性的子系统是 恢复管理子系统 ceil：大于等于 x，并且与它最接近的数。floor：小于等于 x，且与 x 最接近的数。 java的访问权限有public、protected、private和default的，default不能修饰变量。 普通变量不能用 abstract 修饰，abstract 一般修饰类和方法。 数值型变量在默认情况下为int型，byte和short型在计算时会自动转换为int型计算，结果也是int 型。所以 a1*a2 的结果是 int 型的。 12341. byte a1 = 2, a2 = 4, a3;2. short s = 16;3. a2 = s;4. a3 = a1 * a2; stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符。 实际使用通常差不多。 在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流。 只是读写文件，和文件内容无关的，一般选择字节流。 Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 Counter不是并发编程的同步器 类中，可以有main方法，也可以没有main方法，而有一个main()方法的时候，也可以是任意访问权限。因为这个类不一定要执行，可以只是辅助类。 在java 中，声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能给定数组长度。 boolean类型不能和任何类型进行转换，会报出类型异常错误。 1234如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型。 多线程是Java程序的并发机制，它能同步共享数、处理不同的事件。 if的语句比较，除boolean外的其他类型都不能使用赋值语句，否则会提示无法转成布尔值。 管道为空，读操作会被阻塞；管道满了，写操作会被阻塞，管道是内存中的，匿名管道只能单向；命名管道可以双向，可以有多个进程对其读；也可以有多个进程写，只不过不能同时写 会产生信息丢失不如说丢失精度，这样可能更容易明白，而精度丢失只会发生在从大范围到小范围的转换，比如说 int 转换成 double 或 float。 12341. 普通管道（PIPE）：通常有两种限制，一是单工，即只能单向传输；二是血缘，即常用于父子进程间（或有血缘关系的进程间）。2. 流管道（s_pipe）：去除了上述的第一种限制，实现了双向传输。3. 命名管道（name_pipe）：去除了上述的第二种限制，实现了无血缘关系的不同进程间通信。显然，要求是对于不同的服务器之间的通信，是要要求全双工形式的，而管道只能是半双工，虽然可以双向，但是同一时间只能有一个方向传输 Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。注意：finalize不一定被jvm调用，只有当垃圾回收器要清除垃圾时才被调用。 12345671. 尽量使用many-to-one，避免使用单项one-to-many2. 灵活使用单向one-to-many3. 不用一对一，使用多对一代替一对一4. 配置对象缓存，不使用集合缓存5. 一对多使用Bag 多对一使用Set6. 继承使用显示多态 HQL:from object polymorphism=&quot;exlicit&quot; 避免查处所有对象7. 消除大表，使用二级缓存 局部内部类前不能用修饰符public和private,protected 解决哈希冲突常用的两种方法是：开放定址法 和 链地址法 存根（Stub）与 动态链接 有关 泛型仅仅是java的一颗语法糖，它不会影响java虚拟机生成的汇编代码，在编译阶段，虚拟机就会把泛型的类型擦除，还原成没有泛型的代码，顶多编译速度稍微慢一些，执行速度是完全没有什么区别的。 wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入就绪状态，不是运行状态 123456-Xmx：最大堆大小-Xms：初始堆大小-Xmn:年轻代大小-XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值年轻代5120m， Eden：Survivor=3，Survivor区大小=1024m（Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份），总大小为2048m。-Xms初始堆大小即最小内存值为10240m java 中的数据类型分为基本数据和引用数据类型，基本数据类型包括数值型（整数类型：int、short、long、byte，浮点类型：double、float）、布尔型（true）、字符型（char），引用数据类型包括类、接口、数组。 123456789在java.util包中提供了一些集合类，常用的有List、Set和Map类，其中List类和Set类继承了Collection接口。这些集合类又称为容器，长度是可变的，数组用来存放基本数据类型的数据，集合用来存放类对象的引用。 List接口、Set接口、Map接口以及Collection接口的主要特征如下： Collection接口是List接口和Set接口的父接口，通常情况下不被直接使用。List接口继承了Collection接口，List接口允许存放重复的对象，排序方式为按照对象的插入顺序。 Set接口继承了Collection接口，Set接口不允许存放重复的对象，排序方式为按照自身内部的排序规则。 Map接口以键值对（key—value）的形式存放对象，其中键（key）对象不可以重复，值（value）对象可以重复，排序方式为按照自身内部的规则。C：Vector实现了List接口，即间接实现Collection接口D：Iterator是Java迭代器最简单的实现，没有实现Collection接口 1、三目运算是右结合的。2、&amp;不短路，&amp;&amp;短路。 123456基本类型数组: byte[],short[],int[] ,默认值为0, boolean[]默认值为falsefloat[],double[],默认值为0.0对象类型数组:默认值为null 37.123456789101112131415161718EJB容器：Enterprise java bean 容器。更具有行业领域特色。他提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。例如邮件服务、事务管理。JNDI：（Java Naming &amp; Directory Interface）JAVA命名目录服务。主要提供的功能是：提供一个目录系，让其它各地的应用程序在其上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。JMS：（Java Message Service）JAVA消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。JTA：（Java Transaction API）JAVA事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。JAF：（Java Action FrameWork）JAVA安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。RMI/IIOP:（Remote Method Invocation /internet对象请求中介协议）他们主要用于通过远程调用服务。 例如，远程有一台计算机上运行一个程序，它提供股票分析服务，我们可以在本地计算机上实现对其直接调用。当然这是要通过一定的规范才能在异构的系统之间进行通信。RMI是JAVA特有的。 局部内部类 和局部变量一样不能用访问权限修饰符修饰。 1后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。 前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。 同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间 java 中的接口是多继承的，类是单继承的。 12345System.out.println(1+&quot;10&quot;+3+&quot;2&quot;);//11032System.out.println(1+2+&quot;10&quot;+3+&quot;2&quot;);//31032System.out.println(1+&quot;10&quot;+3+1+&quot;2&quot;);//110312System.out.println(1 + &quot;10&quot; + (3 + 1) + 1); // 11041在遇到string类型之前，int间使用 &quot;+&quot; 还是表示数值的相加，但是遇到第一个string后，后面就都是按string类型来了，变成字符串的拼接 Log4j的日志打印级别 不可以 在运行时重新设置 123451. CopyOnWriteArrayList适用于写少读多的并发场景2. ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥， 读与读之间可以并发执行。在读多写少的情况下可以提高效率3. ConcurrentHashMap是同步的HashMap，读写都加锁4. volatile只保证多线程操作的可见性，不保证原子性 String是个不可继承类（final修饰），也是个不可变类（内部char数组被final修饰）。StringBuffer和StringBuilder内部都是一般的动态数组，所以可变。前者是线程安全的，因为方法基本都被synchronized修饰了 一个.java文件中，可以有多个类，包括内部类和外部类。考虑到内部类的原因，一个.java文件可以中可以有多个public类。但是对于外部类而言，一个.java文件必须只能有一个public类，同时这个类的类名必须和.java的文件名一致（包括大小写）。 java继承中对构造函数是不继承的，只是显式或者隐式调用 1234567vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。statck：堆栈类，先进后出hashtable：就比hashmap多了个线程安全enumeration：枚举，相当于迭代器 123456789out-&gt;response.getWriterrequest -&gt;Service方法中的req参数response -&gt;Service方法中的resp参数session -&gt;request.getSessionapplication -&gt;getServletContextexception -&gt;Throwablepage -&gt;thispageContext -&gt;PageContextConfig -&gt;getServletConfig 数组元素在内存中是一个接着一个线性存放的，通过第一个元素就能访问随后的元素，避免了 数据覆盖 的可能性，和 数据类型覆盖 并没有关系。 1234567891011121314151617public class Enclosingone &#123; //非静态内部类 public class InsideOne &#123;&#125; //静态内部类 public static class InsideTwo&#123;&#125;&#125; class Mytest02&#123; public static void main(String args [])&#123; Enclosingone.InsideOne obj1 = new Enclosingone().new InsideOne();//非静态内部类对象 Enclosingone.InsideTwo obj2 = new Enclosingone.InsideTwo();//静态内部类对象 &#125;&#125;内部类其实和类的属性没什么区别，只是在声明的时候必须是Outer.Inner a 就像int a 一样，至于静态内部类和非静态内部类new的时候有点区别 Outer.Inner a=new Outer().new Inner()（非静态，先有Outer对象才能有属性） Outer.Inner a=new Outer.Inner()要把Outer.Inner看成一部分，就像类变量一样 不能用 this 来访问静态变量。 设为x进制，用十进制表示方法13就是 1*x^1+3*x^0=x+3 Object 中有以下方法 getClass(), hashCode(), equals(), clone(), toString(), notify(), notifyAll(), wait(), finalize() 123use-a 是依赖关系has-a 一般是组合关系is-a 一般是继承关系]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用git命令提交代码到github]]></title>
    <url>%2F2018%2F06%2F13%2F%E4%BD%BF%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E5%88%B0github%2F</url>
    <content type="text"><![CDATA[第一步首先我们先要安装git客户端，可以去官网下载。安装完成之后进行第二步。 第二步如果你是第一次提交代码到git仓库，那么在项目根目录，右键然后选择 git bash here，打开之后会进入到git命令行界面。 然后输入git init 初始化仓库。 接着输入 git add .，如果此时你想增加特定的文件只需把 . 更换成你想要添加的文件或文件名即可。 接着输入 git commit -m &quot;描述你此次提交的内容&quot; 接着输入命令，将本地的仓库关联到github上。（远程仓库需要自己在github上事先创建好） git remote add origin ssh地址或https地址 然后执行 git pull origin master。如果此时出现 fatal: refusing to merge unrelated histories 错误，那么我们可以执行 git pull origin master --allow-unrelated-histories 这条命令。 最后执行 git push -u origin master 上传到远程仓库 详细命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Mystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git initReinitialized existing Git repository in D:/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld/.git/Mystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git add Classes/Mystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git add Resources/Mystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git commit -m "first commit"On branch masterUntracked files: .cocos-project.json AppDelegate.cpp AppDelegate.h CMakeLists.txt HelloWorldScene.cpp HelloWorldScene.h cocos2d/ proj.android-studio/ proj.android/ proj.ios_mac/ proj.linux/ proj.win32/nothing added to commit but untracked files presentMystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git remote add origin git@github.com:huxiaolei1997/Plane.gitfatal: remote origin already exists.Mystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git pull origin master --allow-unrelated-historiesFrom github.com:huxiaolei1997/Plane * branch master -&gt; FETCH_HEADMerge made by the 'recursive' strategy. README.md | 2 ++ 1 file changed, 2 insertions(+) create mode 100644 README.mdMystery@Mystery MINGW64 /d/cocos2d-x/cocos2d-x-3.16/tools/cocos2d-console/bin/myprojects/HelloWorld (master)$ git push -u origin masterCounting objects: 46, done.Delta compression using up to 4 threads.Compressing objects: 100% (44/44), done.Writing objects: 100% (46/46), 7.28 MiB | 424.00 KiB/s, done.Total 46 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To github.com:huxiaolei1997/Plane.git 5f1bd95..30d5cad master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'. 总结以上只是讲解了如何使用git命令提交代码到远程仓库，并没有讲解git的安装以及详细配置，如果需要了解这些，请参考下面给出的资料。 起步 - 初次运行 Git 前的配置 Generating a new SSH key and adding it to the ssh-agent]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery对象与JavaScript对象的相互转换]]></title>
    <url>%2F2018%2F06%2F11%2FjQuery%E5%AF%B9%E8%B1%A1%E4%B8%8EJavaScript%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[简介jQuery对象是DOM对象经过jQuery包装之后产生的对象，其是jQuery独有的，可以使用jQuery里面的方法，但不能使用DOM的方法，同样的DOM对象也不能使用jQuery里面的方法， $(&quot;#username&quot;) 是一个jQuery对象， document.getElementById(&quot;username&quot;) 是一个DOM对象，比如我们要给 id 为 username 的 input 标签赋值 test，使用DOM对象中的方法可以这样 document.getElementById(&quot;username&quot;).value = &quot;test&quot;; 而使用jQuery对象可以这样 $(&quot;#username&quot;).val(&quot;test&quot;); 以上两种方式都是单独使用DOM或者jQuery实现给input赋值，那么如果我们获取到了一个jQuery对象，能不能通过某种方式把DOM对象转换成jQuery对象或者把jQuery对象转换成DOM对象呢，答案是肯定的。 jQuery对象转换成DOM对象 12345var username = $(&quot;#username&quot;); #这里获取的是一个jQuery对象var usernameDom = username.get(0); 或者 var username = $username[0] #这里的usernameDom对象现在就是一个DOM对象了，它是从jQuery对象中获取到的 DOM对象转换成jQuery对象123var username = document.getElementById(&quot;username&quot;); #这里获取的是一个DOM对象var $username = $(username); #现在这里的$username对象现在就是一个jQuery对象 参考资料 jQuery对象与js对象互相转换 JQuery对象与javascript对象的转换 jQuery官方英文文档 jQuery中文文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle中分页方式]]></title>
    <url>%2F2018%2F06%2F10%2FOracle%E4%B8%AD%E5%88%86%E9%A1%B5%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Oracle中分页最近在做课程作业的时候，数据库用的是Oracle，其中某个查询出来的结果集数量太多，需要进行分页，为了以后少走弯路，就把这次用到的分页SQL语句记录下来。 分页方式一12345678910111213141516171819202122232425262728select a2.id, a2.userName, a2.add_time from (select a1.id, a1.userName, a1.add_time, rownum rn from ( select id, user_name as userName, add_time from user_info where user_name like concat(&apos;%&apos;, concat(#&#123;keyword&#125;, &apos;%&apos;)) ) a1 where rownum &lt;= #&#123;end_page&#125; ) a2 where a2.rn &gt;= #&#123;start_page&#125; 上面用到几个变量#{start_page}， #{end_page}，#{keyword}，其中 #{start_page} 表示的开始的行数，也就是从第几行开始取出数据（包括该行数据） #{end_page} 表示结束的行数，也就是取出数据到第几行为止（包括该行数据）， #{keyword} 表示搜索的关键词，这里可以自己指定。 分页方式二123456789101112131415161718192021222324select a1.id, a1.userName, a1.add_time from ( select id, user_name as userName, add_time, rownum rn from user_info where user_name like concat(&apos;%&apos;, concat(#&#123;keyword&#125;, &apos;%&apos;)) a1 ) where a1.rn between #&#123;start_page&#125; and #&#123;end_page&#125; 这里的几个变量表示的含义和方式一中的几个变量含义一样。 参考 Oracle数据库分页的三种方法 Oracle分页(limit方式的运用)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Oracle</tag>
        <tag>分页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库连接工具类（适用于Oracle，MySQL）]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8EOracle%EF%BC%8CMySQL%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数据库连接工具类（适用于Oracle，MySQL）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205package com.imooc.ioc.test;import java.io.IOException;import java.io.InputStream;import java.sql.*;import java.util.*;/** * 连接Oracle工具类 * * @author xiaolei hu * @date 2018/6/2 13:28 **/public class JdbcUtil2 &#123; // 表示定义数据库的用户名 private static String USERNAME; // 定义数据库的密码 private static String PASSWORD; // 定义数据库的驱动信息 private static String DRIVER; // 定义访问数据库的地址 private static String URL; // 数据库连接 private Connection connection; // 数据库的执行对象 private PreparedStatement preparedStatement; // 数据库返回的结果集 private ResultSet resultSet; // 初始化配置文件 public JdbcUtil2() &#123; System.out.println("开始加载数据库配置文件"); try &#123; // properties文件具体内容 // jdbc.username=数据库用户名 // jdbc.password=密码 // jdbc.driver=oracle.jdbc.OracleDriver // jdbc.url=jdbc:oracle:thin:@127.0.0.1:1521:orcl InputStream inputStream = JdbcUtil.class.getResourceAsStream("jdbc.properties"); # 这里jdbc.properties文件的位置自己选择 Properties properties = new Properties(); properties.load(inputStream); USERNAME = properties.getProperty("jdbc.username"); PASSWORD = properties.getProperty("jdbc.password"); DRIVER = properties.getProperty("jdbc.driver"); URL = properties.getProperty("jdbc.url"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; System.out.println("数据库配置文件加载成功"); &#125; public Connection getConnection() &#123; try &#123; Class.forName(DRIVER); connection = DriverManager.getConnection(URL, USERNAME, PASSWORD); System.out.println("获取数据库连接成功，connection：" + connection); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return connection; &#125; /** * 执行更新（包括了删除，增加）操作 * * @param sql sql语句 * @param params 执行参数 * @return 执行结果 * @throws SQLException */ public boolean updateByPreparedStatement(String sql, List&lt;?&gt; params) throws SQLException &#123; boolean flag = false; int result = -1; // 表示当用户执行添加删除和修改的时候所影响数据库的行数 preparedStatement = connection.prepareStatement(sql); int index = 1; // 填充sql语句中的占位符 if (params != null &amp;&amp; !params.isEmpty()) &#123; for (int i = 0; i &lt; params.size(); i++) &#123; preparedStatement.setObject(index++, params.get(i)); &#125; &#125; result = preparedStatement.executeUpdate(); flag = result &gt; 0 ? true : false; return flag; &#125; /** * 执行查询操作 * * @param sql sql语句 * @param params 执行参数 * @return * @throws SQLException */ public List&lt;Map&lt;String, Object&gt;&gt; findResult(String sql, List&lt;?&gt; params) throws SQLException &#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); int index = 1; preparedStatement = connection.prepareStatement(sql); if (params != null &amp;&amp; !params.isEmpty()) &#123; for (int i = 0; i &lt; params.size(); i++) &#123; preparedStatement.setObject(index++, params.get(i)); &#125; &#125; resultSet = preparedStatement.executeQuery(); ResultSetMetaData metaData = resultSet.getMetaData(); // 获取查询出来的数据的列数 int cols_len = metaData.getColumnCount(); while (resultSet.next()) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); for (int i = 0; i &lt; cols_len; i++) &#123; // 获取列名（字段名） String cols_name = metaData.getColumnName(i + 1); // 获取该列的值 Object cols_value = resultSet.getObject(cols_name); if (cols_value == null) &#123; cols_value = ""; &#125; map.put(cols_name, cols_value); &#125; list.add(map); &#125; return list; &#125; /** * 释放资源 */ public void releaseConn() &#123; System.out.println("开始释放数据库资源"); if (resultSet != null) &#123; try &#123; resultSet.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (preparedStatement != null) &#123; try &#123; preparedStatement.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (connection != null) &#123; try &#123; connection.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("数据库资源释放成功"); &#125; public static void main(String[] args) &#123; JdbcUtil2 jdbcUtil2 = new JdbcUtil2(); jdbcUtil2.getConnection(); try &#123; // 增加数据 List&lt;Object&gt; paramsInsert = new ArrayList&lt;Object&gt;(); paramsInsert.add("测试"); paramsInsert.add(23); boolean resultInsert = jdbcUtil2.updateByPreparedStatement("insert into user_info(user_name, age) values(?, ?)", paramsInsert); System.out.println(resultInsert); // 删除数据 List&lt;Object&gt; paramsDelete = new ArrayList&lt;Object&gt;(); paramsDelete.add(20); boolean resultDelete = jdbcUtil2.updateByPreparedStatement("delete from user_info where id = ?", paramsDelete); System.out.println(resultDelete); // 更新数据 List&lt;Object&gt; paramsUpdate = new ArrayList&lt;Object&gt;(); paramsUpdate.add(26); paramsUpdate.add(3); boolean result = jdbcUtil2.updateByPreparedStatement("update user_info set age = ? where id = ?", paramsUpdate); System.out.println(result); // 查询数据 List&lt;Object&gt; paramsFind = new ArrayList&lt;Object&gt;(); paramsFind.add(6); List&lt;Map&lt;String, Object&gt;&gt; resultFind = jdbcUtil2.findResult( "select * from user_info where id = ?", paramsFind); for (Map&lt;String, Object&gt; m : resultFind) &#123; System.out.println(m); &#125; //System.out.println(result.toString()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; jdbcUtil2.releaseConn(); &#125; &#125;&#125; 说明依赖管理工具使用的是Maven，其中Oracle驱动的jar包需要自己下载（下载地址）然后添加依赖关系到Maven里，添加命令如下 123456789# 通过cmd运行mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc8 -Dversion=12.2.0.1 -Dpackaging=jar -Dfile=ojdbc8.jar// -Dfile=ojdbc8.jar 是ojdbc8.jar包所在的位置，如果当前所在目录就是ojdbc8.jar所在的目录，那么可以省略完成的路径，下同# 通过powershell运行mvn install:install-file &quot;-DgroupId=com.oracle&quot; &quot;-DartifactId=ojdbc8&quot; &quot;-Dversion=12.2.0.1&quot; &quot;-Dpackaging=jar&quot; &quot;-Dfile=ojdbc8.jar&quot; 参考资料 Java连接Oracle数据库的三种连接方式 Maven下安装oracle jar包依赖关系详细步骤]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis的安装与简单入门]]></title>
    <url>%2F2018%2F05%2F27%2Fredis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redis简介Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 Redis安装（基于CentOS 7）下载redis安装包第一步先去官网下载Redis的安装包（下载地址），这里我下载的是 4.0.9 版本。 使用xftp上传到服务器第二步使用xftp上传到服务器，上传目录可以任意指定，这里我选择的是 /root/ 目录。 解压redis到自己指定的目录第三步解压redis到自己指定的目录，如果不指定，默认解压到当前redis安装包所在的目录 tar -zxvf redis-4.0.9.tar.gz # 解压到当前目录 tar -zxvf redis-4.0.9.tar.gz -C /usr/local/redis # 这里指定解压目录为 /usr/local/redis，redis文件夹需要自己新建 检查是否安装gcc-c++第四步检查是否安装 gcc-c++，如果未安装，则使用 yum 安装 yum install gcc-c++ 编译并安装redis安装完成gcc之后，就可以开始编译redis了，首先进入 /root/redis-4.0.9， redis-4.0.9 是解压之后的文件夹，然后执行 make ，执行完成之后，再继续执行 make PREFIX=/usr/local/redis install #PREFIX指定redis的安装目录，这里redis不需要新建，安装的时候会自动生成 复制redis.conf到安装目录下安装完成之后，我们到解压下的目录复制 redis.conf 到安装目录下（我这里是 /usr/local/redis） cp /root/redis-4.0.9/redis.conf /usr/local/redis 修改配置文件 redis.conf这个时候我们其实已经可以启动redis了，但是这样启动了，redis不是以 守护进程 启动的，我们不能做任何操作，所以需要修改一下配置文件 redis.conf ，找到 daemonize no 修改为 daemonize yes 这样Redis就是以守护进程的方式运行了。 启动redis123456789101112# 启动redis/usr/local/redis/bin/redis-server /usr/local/redis/redis.conf# 关闭redis/usr/local/redis/bin/redis-cli shutdown# 使用redis/usr/local/redis/bin/redis-cli# 以上命令都是包括了完整路径，进入到相应的目录下， 可以省略比如当前就在 /usr/local/redis/bin 目录下，那么启动redis的命令可以这样写./redis-server ../redis.conf 这里还有一点需要注意的是，Redis默认是以 protected-mode 模式运行的，简单来说就是只允许 localhost（127.0.0.1） 本地用户登录，如果要远程登录Redis，那么必须要修改配置文件 redis.conf,找到如下内容 bind 127.0.0.1 protected-mode yes 修改为 #bind 127.0.0.1 protected-mode no 修改完成之后，保存，然后重启Redis，这样就可以远程登录Redis了。 redis安装目录下bin目录中的文件介绍12345redis-benchmark ---性能测试工具redis-check-aof ---aof修复工具redis-check-dump ---rdb 文件检查工具redis-cli ---命令行客户端redis-server ----redis服务器启动命令 什么是守护进程守护进程（Daemon Process），也就是通常说的 Daemon 进程（精灵进程），是 Linux 中的后台服务进程。它是一个生存期较长的进程，通常 独立 于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。 守护进程是个特殊的孤儿进程，这种进程脱离终端，为什么要脱离终端呢？之所以脱离于终端是为了 避免进程被任何终端所产生的信息所打断 ，其在执行过程中的信息也不在任何终端上显示。由于在 Linux 中，每一个系统与用户进行交流的界面称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端就称为这些进程的控制终端，当控制终端被关闭时，相应的进程都会自动关闭。 Linux 的大多数服务器就是用守护进程实现的。比如，Internet 服务器 inetd，Web 服务器 httpd 等。 守护进程参考资料 守护进程]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎上获赞率最高的的66个神回复]]></title>
    <url>%2F2018%2F05%2F25%2F%E7%9F%A5%E4%B9%8E%E4%B8%8A%E8%8E%B7%E8%B5%9E%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%8466%E4%B8%AA%E7%A5%9E%E5%9B%9E%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[很多时候，一句犀利尖锐或充满哲理的话，往往比长篇大论更能打动人、点醒人。当你遇到人生难题的时候，不妨来看看这66个知乎上获赞率最高的神回复吧。 01 Q：交朋友的标准是什么？ A：出世的智者，入世的强者， 或者正常而阳光的普通人。 02 Q：“别让孩子输在起跑线上”有道理吗？ A：一辈子都要和别人去比较，是人生悲剧的源头。 03 Q：做哪些事情可以提升生活品质？ A：定期扔东西。 04 Q：结婚以后两个人在一起最重要的是什么？ A：就当这婚还没结。 05 Q：把学费拿来念书还是环游世界更合适？为什么？ A：在没有充分的知识作为前提的情况下，即使行了万里路，也不过是邮差而已。 06 Q：是不是一个人越成熟就越难爱上一个人？ A：不是越成熟越难爱上一个人，是越成熟越能分辨那是不是爱。 07 Q：你对自由的理解是什么？ A：说“不”的能力。 08 Q：你是如何走出人生的阴霾的？ A：多走几步。 09 Q：哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？ A：夸奖他人。 10 Q：苦难有什么价值？ A：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 11 Q：要怎样努力，才能成为很厉害的人？ A：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。 12 Q：你在生活中得到过的最好的建议是什么？ A：“过度自我关注是万恶之源”“永远不要为尚未发生的事儿拧巴”“觉得为时已晚，恰恰是最早的时候”。 13 Q：前半生与后半生的分界线是在哪里？ A：此时此刻。 14 Q：同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？ A：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 15 Q：如何让这个世界变得美好？ A: 把你自己变得更美好。 16 Q: 二十六岁，工作三年却将留学三年，值得吗？ A: 普通玩家选择标准配置，高端玩家选择自定义配置。 17 Q：世界上有那么多好书好电影注定看不完，我们对这个事实该持何种态度？ A: 怕什么真理无穷，进一寸有一寸的欢喜。 18 Q：听过最落寞的一句话或诗句是什么？ A：不如意事常八九，可与言者无二三。 19 Q：人这一生为什么要努力？ A：最痛苦的事，不是失败，是我本可以。 20 Q：省钱的好办法有哪些？ A：在买任何东西之前牢记：你喜欢，你需要。 21 Q：科学和迷信的分界点是哪里？ A：“我错了。” 22 Q：哪些行为是浪费时间？ A：思而不学＋犹豫不决 23 Q：如果好人不一定得到好报，那我们为什么还要做好事？ A：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。 24 Q：如何看待“年轻的时候需要的是朋友而不是人脉”？ A：没有目的之交往，才能感动人。 25 Q：有哪些道理是你读了不信、听不进去，直到你亲身经历方笃信不疑的？ A：不要低估你的能力，不要高估你的毅力。 26 Q：怎么看待励志的书籍？ A：看再多，那都是别人的人生。 27 Q：你心中的完美爱情是怎么样的？ A：可以有不完美。 28 Q：王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？ A：知道做不到，等于不知道。 29 Q：什么叫见过大世面？ A：能享受最好的，能承受最坏的。 30 Q：为什么当看到好照片时，人们通常的反应是“真不错，你用的是什么相机?”当看到烂照片时，则往往笑话拍摄者水平很臭。 A：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。 31 Q: 如何反驳“现实点，这个社会就是这样”？ A：“你是怎样，你的世界就是怎样。” 32 Q：恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？ A：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 33 Q：情商不高的例子有哪些？ A：对陌生人毕恭毕敬，对亲近的人随意发怒。 34 Q：三十岁才开始学习编程，靠谱吗？ A：种一棵树最好的时间是十年前，其次是现在。 35 Q：怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？ A：说服他人不要诉诸理性，应求于利益。 36 Q：在一个足够小的星球上行走，我们是在上坡还是下坡？ A：你感觉累就是上坡，感觉轻松就是下坡。 37 Q：你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？ A：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。 38 Q：扎克伯格初期是怎么保护Facebook的最初创意？为什么Facebook上线后没被其他大公司抄走? A：保护创意的最好方法，就是 ——将其最好地执行。 39 Q：如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？ A：试图用一句话就来总结复杂的人生，是没有希望的。 40 Q：为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、摆街边早餐小吃摊等“短平快”项目？ A：拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。 41 Q：长期的异国生活，改变了你的哪些“是非观”？ A：很多事情，只是不同，并无是非。 42 Q：向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？ A：也许你弄错了什么是表白。表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 43 Q：最能燃起你学习激情的一句话是什么？ A：你不能把这个世界，让给你所鄙视的人。 44 Q:有哪些我们熟知的名言其实还有后半句？ A：“人是生而自由的”下一句是：“但无往不在枷锁之中”；再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。” 45 Q：脱贫重要还是脱单重要？ A：不谈恋爱死不了，脱贫比脱单更重要。 46 Q：怎样才能在争论中胜过别人？ A：不要跟眼界不一样的人争辩。 47 Q：怎样才能成为一个勇敢的人？ A：做你害怕做的事情，然后你发现，不过如此。 48 Q：怎样才能和三观不合的人做朋友？ A：三观不合真的很难做朋友，因为思想、经历、感官全都不一样。就像我说大海很漂亮，你却说淹死过很多人。 49 Q：刚刚结束了一段十年的爱情，我的人生还有什么意义？ A：年轻的时候，我们爱得死去活来，可随着年岁渐长，你就会发现，爱情并不是生活的全部。善良、努力、读书、健身……让自己变得更好才是人生最重要的事。 50 Q：为什么我总会对失去的东西念念不忘？ A：人们并不是害怕失去，而是害怕失去以后没有更好的可以代替。 51 Q：怎样控制住自己不发脾气？ A：如果你是对的，你没必要发脾气；如果你是错的，你没资格发脾气。 52 Q：用什么方式寻求别人的帮助才不会被拒绝？ A：求人不如求己，靠得住的永远都是自己。 53 Q：被前任伤得很惨，可每次他对我稍微流露出一点温情，我就忍不住又去亲近他，怎么办？ A：再爱的前任，提一次复合就够了。你可以爱三五个人渣，但你不能爱一个人渣三五次。 54 Q：生活是一时艰辛，还是始终如此？ A：成人的世界里，本没有容易二字。 55 Q：“有情饮水饱”这句话对吗？ A：结婚过日子，钱真的很重要，贫贱夫妻百事哀。 56 Q：为什么我想要的东西始终得不到？ A：你越在意什么，什么就会越折磨你。 57 Q：经历多少次失败，才能找到真爱？ A：所有的失恋都是在给真爱让路。 58 Q：男友总说“忙”不陪我，是借口吗？ A：想送你回家的人，东南西北都顺路；愿陪你吃饭的人，酸甜苦辣都爱吃；想见你的人，千山万水都能赶来。 59 Q:做事总也学不会走捷径，怎么办？ A：那些依靠投机取巧走上“人生巅峰”的人，总有一天，会因为一件不经意的小事露出马脚。 60 Q：太在乎自己在别人眼中的形象，导致活得很累，怎么办？ A：没有那么多人关注你，所以，放轻松点，你没有那么多观众。 61 Q：怎样才能找到一个贴心的知己？ A：有时候，你把别人当好朋友，但人家并没有这么想。你所有的朋友都活着，但你还会感到孤独。 62 Q:在当下社会，怎样做一个善良但不软弱的人？ A：永远不要忘记善良。但也不要“过于”善良，因为人们只会挑软柿子捏。 63 Q：怎样挽回一段濒临破裂的友谊？ A：无论是友情还是爱情，跟谁在一起舒服就和谁在一起，累了就躲远一点。你取悦别人的模样，真的不好看。 64 Q：怎样判断是不是真爱？ A：一个人不主动联系你就是不想你，也可能就是不喜欢你；对话时总是三言两语，就是对你没兴趣。 不要再为别人找借口了，事实上，Ta没那么喜欢你，尽快直面或者放弃吧。 65 Q：为什么我评价别人，总是得不到认同？ A：如果不能感同身受，就不要肆意地妄加评判。 66 Q：看上去彼此都没有做错什么，为什么会渐行渐远？ A：所有关系变淡的原因：一个不说，一个不问；或者一个问得尴尬，一个答得敷衍。 转载自「荐读」知乎上获赞率最高的66个神回复，看完整个人都神清气爽]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>知乎</tag>
        <tag>神回复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo接入gitment出现Error: validation failed]]></title>
    <url>%2F2018%2F05%2F25%2Fhexo%E6%8E%A5%E5%85%A5gitment%E5%87%BA%E7%8E%B0Error-validation-failed%2F</url>
    <content type="text"><![CDATA[最近使用hexo搭建了个人博客，文章的评论使用了gitment，在使用gitment的过程中，出现了一个问题就是 Error: validation-failed ，查阅资料才知道，原来就是因为issue的标签label有长度限制！labels的最大长度限制是50个字符。就是因为labels的长度超过了50个字符，才导致评论初始化失败。我们可以修改12345678910在 themes\next\layout_third-party\comments 目录下修改gitments.swig，找到以下代码修改function renderGitment()&#123;var gitment = new &#123;&#123;CommentsClass&#125;&#125;(&#123;id: &apos;&#123;&#123; page.date &#125;&#125;&apos;, #把 id: window.location.pathname 修改成 id: &apos;&#123;&#123; page.date &#125;&#125;&apos;owner: &apos;&#123;&#123; theme.gitment.github_user &#125;&#125;&apos;,repo: &apos;&#123;&#123; theme.gitment.github_repo &#125;&#125;&apos;,&#123;% if theme.gitment.mint %&#125;lang: &quot;&#123;&#123; theme.gitment.language &#125;&#125;&quot; || navigator.language || navigator.systemLanguage || navigator.userLanguage,&#123;% endif %&#125; 就是把时间作为 id ， 根据 时间 来新建issues 参考资料Gitment评论功能接入踩坑教程Hexo+gitment的Error：validation failed]]></content>
      <categories>
        <category>gitment</category>
      </categories>
      <tags>
        <tag>gitment</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于win10搭建PHP环境]]></title>
    <url>%2F2018%2F05%2F25%2F%E5%9F%BA%E4%BA%8Ewin10%E6%90%AD%E5%BB%BAPHP%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[这里是基于win10配置php-7.1.0+apache2.4.23+mysql-5.7.16的介绍，希望能帮到大家。 安装准备 环境 win10 64位（32位的电脑选择下载32位的，32位的软件能在64位的电脑运行，反之则不行，最好是下载和电脑位数匹配的） php-7.1.0 php-7.1.0-Win32-VC14-x64.zip apache 2.4.23 httpd-2.4.23-win64-VC14.zip mysql-5.7.16 mysql-5.7.16-winx64.zip 安装过程下载对应的安装包 先去微软官网下载vc14,网址为https://www.microsoft.com/zh-cn/download/details.aspx?id=48145，这里下载中文简体的，然后下载好之后一步步安装就好了。 下载apache 2.4.23，httpd-2.4.23-win64-VC14.zip，网址为http://www.apachelounge.com/download/，这里选择的是免安装版的。 下载php-7.1.0，php-7.1.0-Win32-VC14-x64.zip 这里我们选择的是线程安全版，关于线程安全版与非线程安全版的区别可 自行上网查阅相关资料，下载网址为http://windows.php.net/download/ ，最后注意选择相应位数的版本下载，这里我是下载64位的。 下载mysql-5.7.16，mysql-5.7.16-winx64.zip，下载网址为http://dev.mysql.com/downloads/mysql/，同样的选择64位的下载。32位的电脑下载32位的。这个软件也是免安装版的，到时候只要解压到某个文件夹就好了。 开始安装 Apache我们这里下载的是zip压缩包，解压后放到合适的位置就好了，这里我们放在E盘的phptools文件夹中的ApacheServer文件夹中，这个文件夹是自己新建的，可以自己命名。 php 下载后也是zip包，同样解压到合适位置，我们这里也将其放在E盘的phptools文件夹下的php7.1目录下,php7.1文件夹需要自己新建。 MySQL选择的是免安装版的，也就是Zip压缩包，这就更简单了，同样是解压到合适的位置，这里我们也将其放在E盘的phptools文件夹下的MySQL目录下,解压安装后如下图 开始配置配置PHP 首先将E:\phptools\php7.1\php.ini-production 复制一份，并重命名为php.ini； 将 E:\phptools\php7.1和E:\phptools\php7.1\ext加入环境变量PATH中,选中计算机，右键属性–&gt;高级系 统设置 –&gt;环境变量–&gt;系统变量，找到Path，编辑，在其后加上;E:\phptools\php7.1;E:\phptools \php7.1\ext，如下图， 开启几个常用的PHP扩展 用记事本打开E:\phptools\php7.1\php.ini 将 ;extension_dir = &quot;ext&quot; 修改为 extension_dir = &quot;ext&quot; （去掉extension前面的分号） 将 ;extension=php_mbstring.dll 修改为 extension=php_mbstring.dll（去掉extension前面的分号,这是php多字节字符串扩展） 将 ;extension=php_mysqli.dll 修改为 extension=php_mysqli.dll（去掉extension前面的分号） 配置Apache 用记事本打开 E:\phptools\ApacheServer\Apache\conf 查找ServerRoot，修改 ServerRoot “C:/Apache24” =&gt; ServerRoot “E:/phptools/ApacheServer/Apache” （这里输入的是你解压apache安装包后放的位置） 查找 #ServerName www.example.com:80 ，修改为 ServerName localhost:80 (去掉前面的#)，如果你的电脑的80端口已经被占用了的话，这里我们就不能用80端口了，可以修改成其它的端口，比如90。当然我们还要搜索Listen，把80端口改成90，其它的就不用修改了，只需要修改这两个地方。 查找 DocumentRoot “c:/Apache24/htdocs” ， 修改为 DocumentRoot “E:/phptools/ApacheServer/Apache/htdocs”。 查找 Directory “c:/Apache24/htdocs” ，修改为 &lt;Directory “ E:/phptools/ApacheServer/Apache/htdocs “。 找到 DirectoryIndex index.html ，修改为 DirectoryIndex index.html index.php index.htm (这里我们添加了 index.php index.htm ) 查找 ScriptAlias /cgi-bin/ “c:/Apache24/cgi-bin/“ ，修改为 ScriptAlias /cgi- bin/ “E:/phptools/ApacheServer/Apache/cgi-bin”。 查找 Directory “c:/Apache24/cgi-bin” 修改为 Directory “E:/phptools/ApacheServer/Apache/cgi-bin/“。 最后在 E:/phptools/ApacheServer/Apache/conf/httpd.conf 最后一行加上 1234LoadModule php7_module &quot;E:/phptools/php7.1/php7apache2_4.dll&quot;AddHandler application/x-httpd-php .php .html .htmAddType application/x-http-php .php .html .htmPHPIniDir &quot;E:/phptools/php7.1&quot; 这些代码。 然后我们如果把Apache安装到系统服务中的话，我们就可以直接在系统服务中启动了。具体方法是打开 任务管理器——&gt;服务——&gt;找到Apache ，然后右键启动就好了。 当然这里不安装也是可以的，只是启动Apache的时候要到 E:\phptools\ApacheServer\Apache\bin\ApacheMonitor.exe 中去，启动前还要运行 httpd.exe 。 配置MySQLMySQL免安装版环境配置已有朋友写过相关经验，我就不赘述了，参考经验朋友niyikai写的经验（MySQL 5.6 for Windows 解压缩版配置安装）即可。但是这里需要注意的是5.7版本里面没有 data 文件夹。在启动之前需要初始化，使用 cmd命令行进入bin文件夹 后，再输入 mysqld –initialize ,这样才能正常启动MySQL。还有密码的问题， 5.7版本的MySQL随机附带了一个登录密码 。这个密码在后来生成的 data 文件夹下。文件的名字是你的 计算机名.err 。2016-12-10T16:18:50.886005Z 1 [Note] A temporary password is generated for root@localhost: fdglskdjggsl 加粗的即为登录密码。还有需要注意的是cmd命令必须是以 管理员权限 运行的，否则权限不够，会报错。下图就是MySQL成功启动并且登录后的界面。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Windows</tag>
        <tag>PHP</tag>
        <tag>win10下PHP环境搭建</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7防火墙、进程管理常用命令]]></title>
    <url>%2F2018%2F05%2F24%2FCentOS7%E9%98%B2%E7%81%AB%E5%A2%99%E3%80%81%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[防火墙Centos7默认安装了 firewalld ，如果没有安装的话，可以使用 yum install firewalld firewalld-config 进行安装。 启动防火墙 systemctl start firewalld 禁用防火墙 systemctl stop firewalld 设置开机启动 systemctl enable firewalld 停止并禁用开机启动 sytemctl disable firewalld 重启防火墙 firewall-cmd --reload 查看状态 systemctl status firewalld或者 firewall-cmd --state 查看版本 firewall-cmd --version 查看帮助 firewall-cmd --help 查看区域信息 firewall-cmd --get-active-zones 查看指定接口所属区域信息 firewall-cmd --get-zone-of-interface=eth0 拒绝所有包 firewall-cmd --panic-on 取消拒绝状态 firewall-cmd --panic-off 查看是否拒绝 firewall-cmd --query-panic 将接口添加到区域(默认接口都在public) firewall-cmd --zone=public --add-interface=eth0(永久生效再加上 --permanent 然后reload防火墙) 设置默认接口区域 firewall-cmd --set-default-zone=public(立即生效，无需重启) 更新防火墙规则 firewall-cmd --reload 或 firewall-cmd --complete-reload (两者的区别就是第一个无需断开连接，就是firewalld特性之一动态 添加规则，第二个需要断开连接，类似重启服务) 查看指定区域所有打开的端口 firewall-cmd --zone=public --list-ports 在指定区域打开端口（记得重启防火墙） firewall-cmd --zone=public --add-port=80/tcp(永久生效再加上 --permanent) 说明： 123–zone 作用域–add-port=8080/tcp 添加端口，格式为：端口/通讯协议–permanent #永久生效，没有此参数重启后失效 进程管理 根据端口查找占用的程序 netstat -apn | grep 4040 杀掉对应的进程 kill -9 26105 #这里26105表示的进程的pid]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>防火墙</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL5.6更改字符集]]></title>
    <url>%2F2018%2F05%2F24%2FMySQL5-6%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[MySQL简介MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境。 更改MySQL字符集（Windows安装版MySQL）我们知道 MySQL 5.6 默认字符集是 latin1 ， latin1 是 ISO-8859-1 的别名，并不是 utf-8 ，这个时候如果我们保存中文到数据库中就会出现乱码，所以我们要更改数据库默认的字符集为 utf-8。 找到ProgramData中的MySQL文件夹中的my.ini文件我们要修改MySQL的字符集，首先要找到 ProgramData 中的MySQL文件夹中的 my.ini 文件（C:\ProgramData\MySQL\MySQL Server 5.6），ProgramData 这个文件夹默认是隐藏在C盘的，我们要在查看里面勾选 隐藏的项目 才能找到这个文件夹。 修改字符集找到 my.ini 文件后，使用 notepad++ 或 editplus 打开编辑这个文件，建议不要使用微软的记事本。添加以下内容 12345678910111213141516# 在 [client] 字段下添加 default-character-set=utf8 [client]default-character-set=utf8 # 没有 [client] 字段自己添加一个# 在 [mysql] 字段下添加 no-auto-rehash default-character-set=utf8[mysql]no-beepno-auto-rehashdefault-character-set=utf8# 在 [mysqld] 字段下添加 character-set-server=utf8[mysqld]character-set-server=utf8 保存之后，退出。在任务管理器里面找到并重启 MySQL56 服务。重启完成之后登陆 MySQL，查看字符集是否修改成功。 show variables like &apos;%char%&apos;; 如果结果如下图所示，那么则证明字符集修改成功 如果发现重启服务之后，编码还没有变为 utf8 的话，那么重启电脑，再重新查看MySQL的字符集。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下各种FTP命令]]></title>
    <url>%2F2018%2F05%2F23%2FWindows%E4%B8%8B%E5%90%84%E7%A7%8DFTP%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近由于某个项目需要用FTP，需要在cmd下访问ftp，用来测试ftp连接是否正常，但自己对cmd下的ftp命令不是很熟悉，所以参考了网上一些资料，写了这篇博客。 Windows下连接ftp首先我们按住 win + r 键，打开运行，输入 cmd, 打开 cmd 页面，然后输入 ftp 111.111.111.111 #这里的111.111.111.111是ftp服务器的地址 紧接着输入ftp用户名，输入用户名之后再输入正确的密码即可登录ftp服务器。登录成功之后，我们需要用到一些命令对ftp上的文件进行操作，比如查看ftp服务器上有多少文件，下载或上传某个文件等。下面就举几个例子来介绍一下几个常用的ftp命令。 上传下载命令比如说我们要上传桌面上的 a.png 到ftp服务器上的根目录下，我们可以这样，首先要切换到桌面（以下操作需要先登录ftp服务器） lcd C:\Users\你电脑的用户名\Desktop 完成之后，我们可以再次输入lcd命令查看当前的本地路径是否已经切换到了桌面 lcd 接着使用 put 命令上传文件到ftp服务器 put a.png 上面这条命令的意思就是上传a.png文件到ftp服务器的根目录下，如果我们不想上传到服务器的根目录呢，那么可以这样 cd images # 切换到images目录下 如果images文件夹不存在，你可以新建一个文件夹 mkdir images 新建文件夹完成之后，这是你可以使用 put 命令上传你想上传的文件到你创建的文件夹下。以上讲的都是上传命令，与上传对应就是下载。我们要下载ftp上的文件可以使用 get 或 mget 命令。 get a.png 上面这条命令表示下载 a.png 到本地，如果你想下载文件到你指定的文件夹，那么可以使用 lcd 命令先切换到对应的目录下 mget *.png 这条命令表示下载 png 格式的所有文件 常用的一些ftp命令 open：与服务器相连接 send(put)：上传文件 get：下载文件 mget：下载多个文件 cd：切换目录 dir：查看当前目录下的文件 del：删除文件 bye：中断与服务器的连接 help: 可以查看ftp所有的命令 查看命令集查看命令集： ascii: 设定以ASCII方式传送文件(缺省值) bell: 每完成一次文件传送,报警提示 binary: 设定以二进制方式传送文件 bye: 终止主机FTP进程,并退出FTP管理方式 case: 当为ON时,用MGET命令拷贝的文件名到本地机器中,全部转换为小写字母 cd: 同UNIX的CD命令 cdup: 返回上一级目录 chmod: 改变远端主机的文件权限 close: 终止远端的FTP进程,返回到FTP命令状态,所有的宏定义都被删除 delete: 删除远端主机中的文件 dir [remote-directory] [local-file]: 列出当前远端主机目录中的文件.如果有本地文件,就将结果写至本地文件 get [remote-file] [local-file]: 从远端主机中传送至本地主机中 help [command]: 输出命令的解释 lcd: 改变当前本地主机的工作目录,如果缺省,就转到当前用户的HOME目录 ls [remote-directory] [local-file]: 同DIR macdef: 定义宏命令 mdelete [remote-files]: 删除一批文件 mget [remote-files]: 从远端主机接收一批文件至本地主机 mkdir directory-name: 在远端主机中建立目录 mput local-files: 将本地主机中一批文件传送至远端主机 open host [port]: 重新建立一个新的连接 prompt: 交互提示模式 put local-file [remote-file]: 将本地一个文件传送至远端主机中 pwd: 列出当前远端主机目录 quit: 同BYE recv remote-file [local-file]: 同GET rename [from] [to]: 改变远端主机中的文件名 rmdir directory-name: 删除远端主机中的目录 send local-file [remote-file]: 同PUT status: 显示当前FTP的状态 system: 显示远端主机系统类型 参考资料 windows下的FTP命令 百度知道]]></content>
      <categories>
        <category>FTP</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于阿里云CentOS安装Tomcat]]></title>
    <url>%2F2018%2F05%2F22%2F%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91CentOS%E5%AE%89%E8%A3%85Tomcat%2F</url>
    <content type="text"><![CDATA[Tomcat简介Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。 安装准备 CentOS xshell, putty, xftp等软件（这些软件的使用请自行Google或百度） 安装好JDK，并配置环境变量，这里不再赘述，有需要的可以参考我之前写的博客（传送门） Apache Tomcat安装包，建议选择7或8这两个版本，不要选择最新的或者很久的版本（下载地址），本次安装我们采用tar包的方式来安装 开始安装上传安装到服务器的目录下首先通过 xftp 上传tomcat安装包到服务器上，目录可以自己选择，我这里选择的是 /usr/tomcat/，tomcat文件夹需要自己新建，本来是不存在的 解压安装包到某个目录然后就是解压安装包到某个目录，要是觉得麻烦，就直接解压到当前目录 tar -zxvf apache-tomcat-8.5.31.tar.gz 要是想解压到指定的目录下，那么可以这样，这条命令的意思就是解压到 /usr/local/tomcat，tomcat这个文件夹需要自己新建 tar -zxvf apache-tomcat-8.5.31.tar.gz -C /usr/local/tomcat/ 编辑setclasspath.sh解压完成之后，我们进入解压后的 tomcat下的bin文件夹，使用vi编辑器编辑 setclasspath.sh 这个文件，在文件末尾加入以下内容，用来指定tomcat启动时使用的jdk，编辑完成之后 :wq保存。12export JAVA_HOME=/usr/java/jdk/jdk1.8.0_112export JRE_HOME=/usr/java/jdk/jdk1.8.0_112/jre 启动Tomcat完成了以上，我们就可以启动Tomcat了。如果8080端口没有被占用的话，那么tomcat就应该启动成功了，如果想通过外网测试tomcat有没有启动成功，需要在 阿里云控制台安全组 和 centos自带的防火墙 开放相应的端口，比如说 8080，只有开放了相应的端口，tomcat才能被外网访问。 启动tomcat /usr/local/tomcat/bin/start.sh 关闭tomcat /usr/local/tomcat/bin/shutdown.sh Tomcat默认端口被占用如果启动Tomcat的时候，发现端口已经被占用了，我们可以先检查Tomcat的端口被哪个进程占用了 netstat -tunlp | grep 8080 #查看占用8080端口的程序 如果这个占用端口的进程无关紧要的话的，我们就可以通过命令强行终止这个进程 kill -9 占用该进程的程序的pid #比如图片中占用80端口的程序的pid是 3685，那么我们就可以这样来终止我们的进程 kill -9 3685 终止占用Tomcat需要使用端口的进程以后，我们就可以重新启动Tomcat但是如果我们占用这个Tomcat的端口的程序很重要不能被终止怎么办，这个时候我们强行终止可能就会有其它错误为了保证服务器的稳定运行，我们可以通过修改Tomcat的端口来避免终止重要的进程 进入 /usr/local/tomcat/conf 这个文件夹下，找到 server.xml 这个文件 使用vi修改Tomcat默认的端口 1234&lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 修改完之后保存并退出，然后重启Tomcat，这个时候Tomcat就可以正常启动了。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>阿里云</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS安装JDK1.8]]></title>
    <url>%2F2018%2F05%2F22%2FCentOS%E5%AE%89%E8%A3%85JDK1-8%2F</url>
    <content type="text"><![CDATA[安装环境及要求 CentOS7 xshell、putty、xftp等软件 本次安装JDK是采用tar包的方式安装 JDK安装包（jdk-8u171-linux-x64.tar.gz），可以从Oracle官网下载（下载地址） 安装过程第一步（使用xftp连接远程服务器，并上传jdk安装包）首先 用xftp连接 上远程服务器，这里我用的是阿里云，然后上传JDK安装包到一个目录下面（比如 /usr/java/ ，java目录需要自己新建） 第二步（删除openjdk，没有则不删除）然后 使用xshell登录 远程服务器，检查当前的服务器是否安装了openjdk，如果有，先卸载 查看是否安装openjdk rpm -qa | grep java 卸载openjdk rpm -e nodeps java-1.8.0-openjdk-1.8.0.101-3.b13.el7_2.x86_64 命令可以卸载当前的openjdk，这里java的rpm包名由于版本不一致可能是不一样的，输入自己的就好了）。 再次查看是否卸载成功 rpm -qa | grep java 第三步（解压tar包到指定目录） 解压tar包到当前目录或者你指定的目录（指定目录不存在需要自己新建） tar -zxvf jdk-8u171-linux-x64.tar.gz（tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/java/） 第四步（设置环境变量）设置环境变量，linux中的环境变量都放置在 /etc/profile/ 文件中，要在文件的末尾添加一些信息。首先输入vi /etc/profile，然后按 insert 键或 i 键，进入编辑模式，在文件末尾添加以下内容。 export JAVA_HOME=/usr/java/jdk1.8.0_171 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin7 这里JAVA_HOME的值是你 解压之后jdk所在的路径 ，每个人都是不一样的，千万不能写错，CLASSPATH和PATH都是一样的不需要修改添加完成以后我们还要使环境变量生效，命令行中输入 source /etc/profile 即可。 最后输入 java -version 即可查看当前安装的jdk版本，但是这个时候只代表我们安装成功了，并没有代表我们配置成功，我们还需要输入 javac 或者 java 来判断是否配置成功，如果输入完成按回车之后，出现的是一大堆java的命令的话，那就代表配置成功了，出现其它的则代表没有配置成功，需要重新配置。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>服务器</tag>
        <tag>JDK</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mystery的第一篇博客]]></title>
    <url>%2F2018%2F05%2F21%2FMystery%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>first blog</category>
      </categories>
      <tags>
        <tag>first blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java IO操作]]></title>
    <url>%2F2018%2F05%2F21%2FJava-IO%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[io操作是Java中重要的一部分，我们在实际开发当中经常会用到它，比如我们要读取某个文本文件的内容或者生成一个新的文件，这些都需要用到 java.io.File 这个类，下面我们就来举两个例子来简单了解一下。 通过FileWriter生成一个文件123456789101112131415161718package com.imooc.ioc.test;import java.io.FileWriter;import java.io.IOException;import java.net.URL;public class WriteAFile &#123; public static void main(String[] args) &#123; try &#123; // 获取当前类所在的目录 URL path = WriteAFile.class.getResource("/"); FileWriter fileWriter = new FileWriter(path.toString().substring(6) + "/Foo.txt"); fileWriter.write("hello foo!"); fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 读取文本文件String filePath = "D:\\Spring\\SpringImoocMaven\\target\\test-classes\\test.txt"; File file = new File(filePath); try { FileReader fileReader = new FileReader(file); //InputStream inputStream = ReadFile.class.getResourceAsStream("/test.txt"); //InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(fileReader); String line = null; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } bufferedReader.close(); //while (reader = fileReader.readline) } catch (java.io.IOException e) { e.printStackTrace(); } 以上代码实现了从文本文件中读取内容并输出到控制台上，我们使用File对象来表示文件，以FileReader来执行实际的读取，并用BufferedReader来让读取更有效率。读取是以while循环来逐行进行，一直到readLine()的果为止。这是最常见的读取数据方式（几乎非序列化对象都是这样的）：以while循环（实际上应该称为while循环测试）来读取，读到没有东西可以读取的时候停止（读取结果为null时停止读取） 要点 用FileWriter这个连接串流来写入文本文件。 将FileWriter链接到BufferedWriter可以提升效率 File对象代表文件的路径而不是文件本身 你可以用File对象来创建、浏览和删除目录 用FileReader来读取文本文件。将FileReader链接到BufferedReader可以提升效率]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
        <tag>FileReader</tag>
      </tags>
  </entry>
</search>
